\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[usenames,dvipsnames,table]{xcolor}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}
\usepackage{listings}

\lstset{ %
	breaklines = true
}

\externaldocument{../../SRS/SRS}
\newcommand{\rref}[1]{R\ref{#1}}
\newcommand{\ddref}[1]{DD\ref{#1}}

\hypersetup{
	bookmarks=true,     % show bookmarks bar?
	colorlinks=true,       % false: boxed links; true: colored links
	citecolor=ForestGreen,
	filecolor=WildStrawberry,
	linkcolor=Purple,
	urlcolor=Cerulean      % color of external links
}

\usepackage{array}

\input{../../Comments}

\newcommand{\progname}{Companion Cube Calculator}
\newcommand{\prognameAbbrv}{$C^{3}$}

\begin{document}

\title{Module Interface Specification for the \progname{} (\prognameAbbrv{})}

\author{Geneva Smith}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
December 7, 2017 & 1.1.1 & Revised the operator data structure with missing 
``get" operator, a new exception, and seperated the \texttt{numOperands} 
Integer state variable into three Boolean state variables; added terminator 
variables to Solver module\\
December 5, 2017 & 1.1 & Added a specification for an operator data structure \\
November 27, 2017 & 1.0 & Initial draft completed\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See SRS Documentation at 
\url{https://github.com/GenevaS/CAS741/tree/master/Doc/SRS} for project 
symbols, abbreviations, and acronyms.

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for the 
\progname{} (\prognameAbbrv{}), a mathematical tool which determines the range 
of a user-specified function given the domains of the function's variables. The 
calculations are performed using interval arithmetic.

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at \url{https://github.com/GenevaS/CAS741}.

It is assumed that the chosen implementation language will automatically check 
that the appropriate number of inputs are provided to a function and that all 
inputs are of the expected type. Therefore, these exceptions are not listed in 
this specification.

\section{Notation}

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \progname. 

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
Boolean & $\mathbb{B}$ & The set of $\{True, False\}$\\
Integer & $\mathbb{Z}$ & Any whole number in (-$\infty$, $\infty$)\\
Real & $\mathbb{R}$ & Any number in (-$\infty$, $\infty$)\\
\multirow{2}{1cm}{String} & \multirow{2}{1cm}{$char^n$} & A sequence of 
alphanumeric and special characters\\
\bottomrule
\end{tabular} 
\end{center}

\noindent
The specification of \progname \ uses some derived data types: sequences, strings, and
tuples. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \progname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.

\newpage
\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this 
project. It can be found at 
\url{https://github.com/GenevaS/CAS741/blob/master/Doc/Design/MG}.

\begin{table}[h!]
	\centering
	\begin{tabular}{p{0.35\textwidth} p{0.6\textwidth}}
		\toprule
		\textbf{Level 1} & \textbf{Level 2}\\
		\midrule
		
		{Hardware-Hiding Module} & - \\
		\midrule
		
		\multirow{7}{0.29\textwidth}{Behaviour-Hiding Module} & Control Flow 
		Module \\
		& User Input Module \\
		& Interval Conversion Module \\
		& Equation Conversion Module \\
		& Variable Consolidation Module \\
		& Range Solver Module \\
		& Output Module \\
		\midrule
		
		\multirow{2}{0.29\textwidth}{Software Decision Module} & Interval Data 
		Structure Module \\
		& Equation Data Structure Module \\
		& Operator Data Structure Module \\
		\bottomrule
		
	\end{tabular}
	\caption{Module Hierarchy}
	\label{TblMH}
\end{table}

~\newpage

\section{MIS of the Control Flow Module} 
\label{Module_controlflow}

\subsection{Module}

Main

\subsection{Uses}

Input (Section~\ref{Module_userinput}), Consolidate 
(Section~\ref{Module_variableconsolidation}), Solver 
(Section~\ref{Module_rangesolver}), Output (Section~\ref{Module_output}), 
IntervalStruct (Section~\ref{Module_intervaldatastructure}), EquationStruct 
(Section~\ref{Module_equationdatastructure})


\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{3cm} p{3cm} p{3cm} p{5cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
Main & - & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

N/A

\subsubsection{Access Routine Semantics}

\noindent Main():
\begin{itemize}
\item transition: Create data structures to contain the user inputs and modify 
their states for the Output module.
\end{itemize}

\begin{lstlisting}
# Get User Input
  userInputs := Input.GetUserInputs()
  eqString := userInputs[0]
  varList := userInputs[1, userInputs.Length - 1]    
 
# Convert input into equation and interval data structures using 
# the list of valid operators from Solver
  operators := Solver.GetValidOperators()
  Consolidate.ConvertAndCheckInputs(eqString, varList, operators)
  
# Get the equation and interval data structures and pass them to 
# the Solver module
  equationData := Consolidate.GetEquationStruct()
  intervalDataList := Consolidate.GetIntervalStructList()
  range := Solver.CalculateRange(equationData, intervalDataList)
  
# Report the results back to the user
  Output.PrintInterval(range)
  Output.PrintEquationTree(equationData)
  for each interval in intervalDataList:
    Output.PrintInterval(interval)
\end{lstlisting}

\newpage

\section{MIS of the User Input Module} 
\label{Module_userinput}

\wss{Should GetUserInputs take a string is input for when the user wants to
  obtain the inputs from a file.}
\wss{Do you really want the output to be a sequence of strings?  What about
  defining an ADT that stores this information, or an abstract object, if there
  is only one?}

\subsection{Module}

Input

\subsection{Uses}

N/A

\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3cm} p{3cm} p{3cm} p{5cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		\multirow{2}{3cm}{GetUserInputs} & \multirow{2}{3cm}{-} & 
		\multirow{2}{3cm}{$String^n$} & IN\_BAD\_FILE, \\
		 &  &  & IN\_EMPTY\_FILE \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{Environment Variables}

$inputFile$ : $String^n$

\subsubsection{State Variables}

N/A

\subsubsection{Assumptions}

\begin{itemize}
	\item The GetInputMethod function accepts user inputs from files or as 
	direct inputs (From SRS \rref{R_Inputs}).
	
	\item If the user chooses to enter their values via a file, it must be 
	formatted such that:	
	\begin{itemize}
		\item The user equation on the first line
		\item The list of variable names and interval values associated with 
		the user equation; each name/value set is on its own line and is of the 
		form $varName, minBound$, $maxBound$ \wss{What happens if the
                  variables in the equation do not match the list of variable names?}
	\end{itemize}

	\item The output of the GetUserInputs function is a list of $String$ where 
	the first item is the user equation. The remaining items are the variable 
	names and interval values such that every set of three values represents 
	one data set. 
\end{itemize}


\subsubsection{Access Routine Semantics}

\noindent GetUserInputs():
\begin{itemize}
	\item transition: If the user has chosen to enter their values via a file, 
	$inputFile$ is associated with the provided file name.
	\item output: $out := eqString || varList$
	\item exception: $exc := \\
	(\nexists inputFile \vee \neg Read(inputFile) \Rightarrow IN\_BAD\_FILE)\\
	|\\
	(Read(inputFile) == \emptyset \Rightarrow IN\_EMPTY\_FILE)$
\end{itemize}

\newpage

\section{MIS of the Interval Conversion Module} 
\label{Module_intervalconversion}

\wss{Why even create the intermediate string form?  Why not go directly to the
  intervalStruct type?}

\subsection{Module}

IntervalConversion

\subsection{Uses}

IntervalStruct (Section~\ref{Module_intervaldatastructure})

\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3cm} p{2.3cm} p{3cm} p{5cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		\multirow{6}{3cm}{MakeInterval} & \multirow{6}{2.3cm}{$String^3$} & 
		\multirow{6}{3cm}{$intervalStruct$} & IVC\_EMPTY\_VARNAME, \\
		& & & IVC\_CONV\_ERR\_MIN, \\
		& & & IVC\_CONV\_ERR\_MAX, \\
		& & & IVC\_NO\_BOUNDS, \\
		& & & IVC\_NO\_MIN, \\
		& & & IVC\_NO\_MAX\\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

N/A

\subsubsection{Assumptions}

\begin{itemize}
	\item Ensuring that $min \leq max$ is handled by the IntervalStruct 
	(Section~\ref{Module_intervaldatastructure}) module.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent MakeInterval($varName, min, max$):
\begin{itemize}
	\item output: $out := newInterval$ \wss{Where is newInterval defined?}
	\item exception: $exc := \\
	(varName = ``" \Rightarrow IVC\_EMPTY\_VARNAME)\\
	|\\
	(ToReal(min) \notin \mathbb{R} \Rightarrow IVC\_CONV\_ERR\_MIN)\\
	|\\
	(ToReal(max) \notin \mathbb{R} \Rightarrow IVC\_CONV\_ERR\_MAX)\\
	|\\
	(min = max = ``" \Rightarrow IVC\_NO\_BOUNDS)\\
	|\\
	(min = ``" \wedge max \neq ``" \Rightarrow IVC\_NO\_MIN)\\
	|\\
	(min \neq ``" \wedge max = ``" \Rightarrow IVC\_NO\_MAX)$
\end{itemize}

\newpage

\section{MIS of the Equation Conversion Module} 
\label{Module_equationconversion}

\subsection{Module}

EquationConversion

\subsection{Uses}

EquationStruct (Section~\ref{Module_equationdatastructure}), OperatorStruct (Section~\ref{Module_operatordatastructure})

\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3.2cm} p{2.8cm} p{3cm} p{5cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		\multirow{4}{3.2cm}{MakeEquationTree} & \multirow{4}{2.8cm}{$String$, 
		$operatorStruct^n$} & \multirow{4}{3cm}{$equationStruct$} & 
		EQC\_CONST\_FUNC, \\	
		& & & EQC\_IMPLICIT\_MULT, \\
		& & & EQC\_INCOMPLETE\_OP, \\
		& & & EQC\_UNSUPPORTED\_OP \\
		GetVariableList & - & $String^n$ & - \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
	\item $variableList$ : $String^n$
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
	\item The MakeEquationTree function will always be called before the 
	GetVariableList function, otherwise it will not contain any data.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent MakeEquationTree($userEquation, supportedOperations$):
\begin{itemize}
	\item transition: The value of $variableList$ is updated with new variable 
	names as they are encountered during equation processing.
	\item output: $out := equationTreeRoot$ \wss{Where is this output
            defined?  I would expect it to be defined in terms of the input parameters.}
	\item exception: $exc := \\
	(ToReal(userEquation) \in \mathbb{R} \Rightarrow EQC\_CONST\_FUNC)\\
	|\\
	(\exists subEq | subEq = \{subEq_1, subEq_2\} \wedge subEq_1 \in \mathbb{R} 
	\wedge subEq_2 \in variableList \\ \Rightarrow EQC\_IMPLICIT\_MULT)\\
	|\\
	(\exists op \in userEquation | (NULL<op>userEquation) \vee 
	(userEquation<op>NULL) \Rightarrow EQC\_INCOMPLETE\_OP)\\
	|\\
	(\exists op | op \in userEquation \wedge op \notin supportedOperations 
	\Rightarrow EQC\_UNSUPPORTED\_OP)$
\end{itemize}

\noindent GetVariableList():
\begin{itemize}
	\item output: $out := variableList$
	\item exception: N/A
\end{itemize}

\newpage

\section{MIS of the Variable Consolidation Module} 
\label{Module_variableconsolidation}

\subsection{Module}

Consolidate

\subsection{Uses}

IntervalConversion (Section~\ref{Module_intervalconversion}), 
EquationConversion (Section~\ref{Module_equationconversion}), IntervalStruct 
(Section~\ref{Module_intervaldatastructure}), EquationStruct 
(Section~\ref{Module_equationdatastructure})


\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{4.3cm} p{2.7cm} p{3cm} p{4.3cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		\multirow{4}{4.3cm}{ConvertAndCheckInputs} & 
		\multirow{4}{2.3cm}{$String$, $String^n$, $operatorStruct^n$} & 
		\multirow{4}{3cm}{-} & VC\_MISSING\_VARS, \\
		& & & VC\_EXTRA\_VARS, \\
		& & & VC\_NO\_FUNCTION, \\
		& & & VC\_INVALID\_VARNAME \\
		GetEquationStruct & - & $equationStruct$ & - \\
		GetIntervalStructList & - & $intervalStruct^n$ & - \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
	\item $equationTreeRoot$ : $equationStruct$
	\item $intervalList$ : $intervalStruct^n$
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
	\item The ConvertAndCheckInputs function will change the state variables 
	before the GetEquationStruct or GetIntervalStructList functions are called.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent ConvertAndCheckInputs(eqString, varList, operators):
\begin{itemize}
	\item transition: The state variables $equationTreeRoot$ and $intervalList$ 
	will be assigned the values that result from a successful parse and 
	consolidation process. \wss{How is this done?  If you cannot represent
          it formally, maybe a pseudo code algorithm is available?}
	\item output: N/A 
	\item exception: $exc := \\
	(\exists var | var \in eqString \wedge var \notin varList \Rightarrow 
	VC\_MISSING\_VARS)\\
	|\\
	(\exists var | var \notin eqString \wedge var \in varList \Rightarrow 
	VC\_EXTRA\_VARS)\\
	|\\
	(eqString == ``" \Rightarrow VC\_NO\_FUNCTION)\\
	|\\
	(\exists varName \supset \{+, - , *, \, \string^, (, )\} \Rightarrow 
	VC\_INVALID\_VARNAME)$
\end{itemize}

\noindent GetEquationStruct():
\begin{itemize}
	\item output: $out := equationTreeRoot$
	\item exception: N/A
\end{itemize}

\noindent GetIntervalStructList():
\begin{itemize}
	\item output: $out := intervalList$ 
	\item exception: N/A
\end{itemize}

\newpage

\section{MIS of the Range Solver Module} 
\label{Module_rangesolver}

\subsection{Module}

Solver

\subsection{Uses}

IntervalStruct (Section~\ref{Module_intervaldatastructure}), EquationStruct 
(Section~\ref{Module_equationdatastructure}), OperatorStruct (Section~\ref{Module_operatordatastructure})

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
	\item $supportedOps : operatorStruct^n$
	\item $supportedTerminators : String^n$
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3.5cm} p{3cm} p{3cm} p{5cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		GetValidOperators & - & $operatorStruct^n$ & -\\
		GetValidTerminators & - & $String^n$ & -\\
		\multirow{2}{3.1cm}{FindRange} & $equationStruct$, $intervalStruct^n$ & 
		\multirow{2}{3cm}{$intervalStruct$} & 
		\multirow{2}{5cm}{SOL\_UNSUPPORTED\_OP}\\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

N/A

\subsubsection{Assumptions}

\begin{itemize}
	\item The type of $intervalStruct^n$ accepts \texttt{NULL} as a valid value.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent GetValidOperators():
\begin{itemize}
	\item output: $out := supportedOps$
	\item exception: N/A
\end{itemize}

\noindent GetValidTerminators():
\begin{itemize}
	\item output: $out := supportedTerminators$
	\item exception: N/A
\end{itemize}

\noindent FindRange($eStruct, ivStructList$):
\begin{itemize}
	\item output: $out := eqRange$
	\item exception: $exc := \\
	((\exists op \in eStruct \wedge op \notin supportedOps) \\
	\vee (\exists iv1, iv2 \in ivStructList \wedge \nexists op \in supportedOps 
	| op(iv1, iv2) \vee op(iv2, iv1)) \\
	\Rightarrow SOL\_UNSUPPORTED\_OP)$ 
\end{itemize}

\newpage

\section{MIS of the Output Module} 
\label{Module_output}

\subsection{Module}

Output

\subsection{Uses}

IntervalStruct (Section~\ref{Module_intervaldatastructure}), EquationStruct 
(Section~\ref{Module_equationdatastructure})

\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3.1cm} p{3cm} p{3cm} p{5cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		PrintInterval & $intervalStruct$ & - & - \\
		PrintEquationTree & $equationStruct$ & - & - \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

N/A

\subsubsection{Environment Variables}

\begin{itemize}
	\item cmd: the command-line interface
	\item win: a 2D sequence of pixels displayed on the screen
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
	\item There are no exceptions in this module because it is assumed that 
	only well-formed inputs will be passed in. This assumption is made knowing 
	that this module will only be called post-process and any errors in the 
	data structures have already been identified.
	\item The object passed to PrintEquationTree is the root of the equation 
	tree
\end{itemize}


\subsubsection{Access Routine Semantics}

\noindent PrintIntervalList($iStruct$):
\begin{itemize}
	\item transition: If the user interface is the command-line, write the 
	interval $iStruct$ to cmd. If the user interface is a GUI, modify win so 
	that the interval is displayed. In both cases, the variable name of the 
	interval must also be displayed.
	\item exception: N/A
\end{itemize}

\noindent PrintEquationTree($eStruct$):
\begin{itemize}
	\item transition: If the user interface is the command-line, write the 
	equation tree represented by $eStruct$ to cmd. If the user interface is a 
	GUI, modify win so that the equation tree is displayed.
	\item exception: N/A
\end{itemize}

\newpage

\section{MIS of the Interval Data Structure Module} 
\label{Module_intervaldatastructure}

\subsection{Module}

IntervalStruct

\subsection{Uses}

N/A

\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3cm} p{3cm} p{3cm} p{5cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline		
		IntervalStruct & $String$, $\mathbb{R}^2$ & $intervalStruct$ & 
		IV\_ORD\_VIOLATED \\
		GetVariableName & - & $String$ & - \\
		GetMinBound & - & $\mathbb{R}$ & - \\
		GetMaxBound & - & $\mathbb{R}$ & - \\
		SetVariableName & $String$ & - & - \\
		SetMinBound & $\mathbb{R}$ & - & IV\_ORD\_VIOLATED \\
		SetMaxBound & $\mathbb{R}$ & - & IV\_ORD\_VIOLATED \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\# For \rref{R_conditionX} using \ddref{DD_interval}
\begin{itemize}
	\item $variableName$ : $String$
	\item $minBound : \mathbb{R}$
	\item $maxBound : \mathbb{R}$
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent IntervalStruct($varName, minB, maxB$):
\begin{itemize}
	\item output: $out := newInterval$
	\item transition: Update state variables $variableName$, $minBound$, and 
	$maxBound$ with the provided values $varName$, $minB$, and $maxB$
	\item exception: $exc := \\
	(minB > maxB \Rightarrow IV\_ORD\_VIOLATED)$
\end{itemize}

\noindent GetVariableName():
\begin{itemize}
	\item output: $out := variableName$
	\item exception: N/A
\end{itemize}

\noindent GetMinBound():
\begin{itemize}
	\item output: $out := minBound$
	\item exception: N/A
\end{itemize}

\noindent GetMaxBound():
\begin{itemize}
	\item output: $out := maxBound$
	\item exception: N/A
\end{itemize}

\noindent SetVariableName($varName$):
\begin{itemize}
	\item transition: Update state variable $variableName$ with the provided 
	value $varName$
	\item exception: N/A
\end{itemize}

\noindent SetMinBound($minB$):
\begin{itemize}
	\item transition: Update state variable $minBound$ with the provided value 
	$minB$
	\item exception: $exc := \\
	(minB > maxBound \Rightarrow IV\_ORD\_VIOLATED)$
\end{itemize}

\noindent SetMaxBound($maxB$):
\begin{itemize}
	\item transition: Update state variable $maxBound$ with the provided value 
	$maxB$
	\item exception: $exc := \\
	(maxB < minBound \Rightarrow IV\_ORD\_VIOLATED)$
\end{itemize}

\newpage

\section{MIS of the Equation Data Structure Module} 
\label{Module_equationdatastructure}

\subsection{Module}

EquationStruct

\subsection{Uses}

N/A

\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3cm} p{3cm} p{3cm} p{5cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		\multirow{2}{3cm}{EquationStruct} & $String^2$, $equationStruct^2$ & 
		\multirow{2}{3cm}{$equationStruct$} & 
		\multirow{2}{5cm}{-}\\
		GetOperator & - & $String$ & - \\
		GetVariableName & - & $String$ & - \\
		GetLeftOperand & - & $equationStruct$ & -\\
		GetRightOperand & - & $equationStruct$ & - \\
		SetLeftOperand & $equationStruct$ & - & - \\
		SetRightOperand & $equationStruct$ & - & - \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\# To support \rref{R_conditionfx} and \rref{R_CalculateCompose}
\begin{itemize}
	\item $operator : String$
	\item $variableName : String$
	\item $leftOperand : equationStruct$
	\item $rightOperand : equationStruct$
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
	\item The decomposition of the user equation is handled by the Equation 
	Conversion module (Section~\ref{Module_equationconversion}).
	\item Unsupported operators are identified and handled in the Equation 
	Conversion module (Section~\ref{Module_equationconversion}).
	\item There is no setter method for the $operator$ or $variableName$ fields 
	because they will not be changed after initialization.
	\item The values for $leftOperand$ and $rightOperand$ can be set to 
	\texttt{NULL} as required.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent EquationStruct($op, vName, eStruct1, eStruct2$):
\begin{itemize}
	\item output: $out := newEquation$
	\item transition: Update state variables $operator$, $variableName$, 
	$leftOperand$, and $rightOperand$ with the provided values $op$, $vName$, 
	$eStruct1,$ and $eStruct2$
	\item exception: N/A
\end{itemize}

\noindent GetOperator():
\begin{itemize}
	\item output: $out := operator$
	\item exception: N/A
\end{itemize}

\noindent GetVariableName():
\begin{itemize}
	\item output: $out := variableName$
	\item exception: N/A
\end{itemize}

\noindent GetLeftOperand():
\begin{itemize}
	\item output: $out := leftOperand$
	\item exception: N/A
\end{itemize}

\noindent GetRightOperand():
\begin{itemize}
	\item output: $out := rightOperand$
	\item exception: N/A
\end{itemize}

\noindent SetLeftOperand($eStruct$):
\begin{itemize}
	\item transition: Update state variable $leftOperand$ with the provided 
	value $eStruct$
	\item exception: N/A
\end{itemize}

\noindent SetRightOperand($eStruct$):
\begin{itemize}
	\item transition: Update state variable $rightOperand$ with the provided 
	value $eStruct$
	\item exception: N/A
\end{itemize}

\newpage

\section{MIS of the Operator Data Structure Module} 
\label{Module_operatordatastructure}

\wss{Do you really want to add operators in this way?  Don't you already know
  that your operators are addition, subtraction, multiplication and division?  I
  like the idea of flexibility, but this might not be the right kind of
  flexibility.}

\subsection{Module}

OperatorStruct

\subsection{Uses}

N/A

\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3cm} p{3cm} p{3cm} p{5cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		\multirow{3}{3cm}{OperatorStruct} & \multirow{3}{3cm}{$String$, $Int$, 
		$Boolean^4$} & \multirow{3}{3cm}{$operatorStruct$} & OP\_MISSING\_OP, 
		OP\_MULTI\_TYPE, OP\_NO\_TYPE\\
		GetOperator & - & $String$ & - \\
		GetPrecedence & - & $Int$ & - \\
		IsUnary & - & $Boolean$ & - \\
		IsBinary & - & $Boolean$ & - \\
		IsTernary & - & $Boolean$ & - \\
		IsLeftAssociative & - & $Boolean$ & -\\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
	\item $operator : String$
	\item $precedence : Int$
	\item $isUnary : Boolean$
	\item $isBinary : Boolean$
	\item $isTernary : Boolean$
	\item $leftAssociative : Boolean$
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
	\item There are no Setter methods for this module because operator properties are fixed.
	\item A low integer value is associated with a high precedence operation.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent OperatorStruct($op, prec, isUnary, isBinary, isTernary, isLeftAssociative$):
\begin{itemize}
	\item output: $out := newOperator$
	\item transition: Update state variables $operator$, $precedence$, 
	$isUnary$, $isBinary$, $isTernary$, and $leftAssociative$ with the provided 
	values $op$, $prec$, $isUnary$, $isBinary$, $isTernary$, and 
	$isLeftAssociative$.
	\item exception: $exc := \\
	(op = ``" \Rightarrow OP\_MISSING\_OP)\\
	|\\
	((isUnary = isBinary \wedge isUnary = True) \vee (isUnary = isTernary 
	\wedge isUnary = True) \vee (isBinary = isTernary \wedge isBinary = True) 
	\Rightarrow OP\_MULTI\_TYPE)\\
	|\\
	(isUnary = isBinary = isTernary \wedge isUnary = False \Rightarrow 
	OP\_NO\_TYPE)$
\end{itemize}

\noindent GetOperator():
\begin{itemize}
	\item output: $out := operator$
	\item exception: N/A
\end{itemize}

\noindent GetPrecedence():
\begin{itemize}
	\item output: $out := precedence$
	\item exception: N/A
\end{itemize}

\noindent IsUnary():
\begin{itemize}
	\item output: $out := isUnary$
	\item exception: N/A
\end{itemize}

\noindent IsBinary():
\begin{itemize}
	\item output: $out := isBinary$
	\item exception: N/A
\end{itemize}

\noindent IsTernary():
\begin{itemize}
	\item output: $out := isTernary$
	\item exception: N/A
\end{itemize}

\noindent IsLeftAssociative():
\begin{itemize}
	\item output: $out := leftAssociative$
	\item exception: N/A
\end{itemize}

\newpage

\bibliographystyle {plainnat}
\bibliography {../../../ReferenceMaterial/References}

\newpage

\section{Appendix} \label{Appendix}

\renewcommand{\arraystretch}{1.2}

\begin{longtable}{l p{9.5cm}}
	\caption{Possible Error Exceptions} \\
	\toprule
	\textbf{Message ID} & \textbf{Error Message} \\
	\midrule
	EQC\_UNSUPPORTED\_OP & Error: The user equation contains an unsupported 
	operator. Supported operators include $<supportedOperators>$.\\
	EQC\_INCOMPLETE\_OP & Error: An operator was found that does not have 
	sufficient operands. \\
	IN\_BAD\_FILE & Error: The file could not be read. \\
	IN\_EMPTY\_FILE & Error: The file was empty. \\
	IVC\_CONV\_ERR\_MIN & Error: The string provided for the minimum bound 
	cannot be converted to a real number. \\
	IVC\_CONV\_ERR\_MAX & Error: The string provided for the maximum bound 
	cannot be converted to a real number.\\
	IVC\_EMPTY\_VARNAME & Error: Intervals must have an associated variable 
	name. \\
	IVC\_NO\_BOUNDS & Error: No values provided for either interval bound. \\
	OP\_MISSING\_OP & Error: Cannot have an operator with no representative symbol. \\
	OP\_MULTI\_TYPE & Error: An operator cannot be overloaded to be unary, 
	binary, and ternary. \\
	OP\_NO\_TYPE & Error: Operators must be assigned a number of operands type. 
	\\
	SOL\_UNSUPPORTED\_OP & Error: An unsupported operation was encountered 
	while solving for the range of the equation.\\
	VC\_INVALID\_VARNAME & Error: Encountered a variable name with reserved 
	characters ($+, - , *, \, \string^, (, )$). \\
	VC\_MISSING\_VARS & Error: A variable is referenced in the user equation 
	that does not exist in the variable list. \\
	VC\_NO\_FUNC & Error: No user equation was received. \\
	\bottomrule
\end{longtable}

\newpage

\begin{longtable}{l p{9.5cm}}
	\caption{Possible Warning Exceptions} \\
	\toprule
	\textbf{Message ID} & \textbf{Error Message} \\
	\midrule
	EQ\_WRONG\_OPERATOR\_TYPE & Warning: The operator must have type $string$. 
	String type conversion has been applied.\\
	EQ\_WRONG\_VARNAME\_TYPE & Warning: The variable name must have type 
	$string$. String type conversion has been applied. \\
	EQC\_CONST\_FUNC & Warning: The user equation is a constant value and the 
	range will only include this value.\\
	EQC\_IMPLICIT\_MULT & Warning: Encountered an implicit multiplication of a 
	constant value and a variable. Expanding with explicit operator. \\
	IV\_ORD\_VIOLATED & Warning: Value provided for intervals are not in 
	increasing order. The values have been exchanged to maintain the interval 
	ordering. \\
	IVC\_NO\_MIN & Warning: No minimum interval bound given. Setting it to the 
	same value as the maximum bound. \\
	IVC\_NO\_MAX & Warning: No maximum interval bound given. Setting it to the 
	same value as the minimum bound. \\
	VC\_EXTRA\_VARS & Warning: There are more variables in the variable list 
	than the user equation. Extraneous variables will be ignored. \\
	\bottomrule
\end{longtable}

\end{document}