\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[usenames,dvipsnames,table]{xcolor}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}
\usepackage{listings}

\lstset{ %
	breaklines = true
}

\externaldocument{../../SRS/SRS}
\newcommand{\rref}[1]{R\ref{#1}}
\newcommand{\ddref}[1]{DD\ref{#1}}

\hypersetup{
	bookmarks=true,     % show bookmarks bar?
	colorlinks=true,       % false: boxed links; true: colored links
	citecolor=ForestGreen,
	filecolor=WildStrawberry,
	linkcolor=Purple,
	urlcolor=Cerulean      % color of external links
}

\usepackage{array}

\input{../../Comments}

\newcommand{\progname}{Companion Cube Calculator}
\newcommand{\prognameAbbrv}{$C^{3}$}

\begin{document}

\title{Module Interface Specification for the \progname{} (\prognameAbbrv{})}

\author{Geneva Smith}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
December 17, 2017 & 1.2 & Updated the Control Flow and Input specifications to 
match the resulting implementation \\
December 7, 2017 & 1.1.1 & Revised the operator data structure with missing 
``get" operator, a new exception, and seperated the \texttt{numOperands} 
Integer state variable into three Boolean state variables; added terminator 
variables to Solver module\\
December 5, 2017 & 1.1 & Added a specification for an operator data structure \\
November 27, 2017 & 1.0 & Initial draft completed\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See SRS Documentation at 
\url{https://github.com/GenevaS/CAS741/tree/master/Doc/SRS} for project 
symbols, abbreviations, and acronyms.

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}
The following document details the Module Interface Specifications for the 
\progname{} (\prognameAbbrv{}), a mathematical tool which determines the range 
of a user-specified function given the domains of the function's variables. The 
calculations are performed using interval arithmetic.

It is assumed that the chosen implementation language will automatically check 
that the appropriate number of inputs are provided to a function and that all 
inputs are of the expected type. Therefore, these exceptions are not listed in 
this specification.

Complementary documents include the System Requirement Specifications
and Module Guide. The full documentation and implementation can be
found at:
\begin{center}
	\href{https://github.com/GenevaS/CAS741}{https://github.com/GenevaS/CAS741}
\end{center}

\newpage

\section{Notation}
The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \progname. 

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
Boolean & $\mathbb{B}$ & The set of $\{True, False\}$\\
Integer & $\mathbb{Z}$ & Any whole number in (-$\infty$, $\infty$)\\
Real & $\mathbb{R}$ & Any number in (-$\infty$, $\infty$)\\
\multirow{2}{1cm}{String} & \multirow{2}{1cm}{$char^n$} & A sequence of 
alphanumeric and special characters\\
\bottomrule
\end{tabular} 
\end{center}

\noindent
The specification of \progname{} uses some derived data types: sequences and 
strings. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. In addition, \progname{} uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.

\newpage

\section{Module Decomposition}
The following table is taken directly from the Module Guide document for this 
project. It can be found at 
\href{https://github.com/GenevaS/CAS741/blob/master/Doc/Design/MG}{https://github.com/GenevaS/CAS741/blob/master/Doc/Design/MG}.

\begin{table}[h!]
	\centering
	\begin{tabular}{p{0.35\textwidth} p{0.6\textwidth}}
		\toprule
		\textbf{Level 1} & \textbf{Level 2}\\
		\midrule
		
		{Hardware-Hiding Module} & - \\
		\midrule
		
		\multirow{7}{0.29\textwidth}{Behaviour-Hiding Module} & Control Flow 
		Module \\
		& User Input Module \\
		& Interval Conversion Module \\
		& Equation Conversion Module \\
		& Variable Consolidation Module \\
		& Range Solver Module \\
		& Output Module \\
		\midrule
		
		\multirow{2}{0.29\textwidth}{Software Decision Module} & Interval Data 
		Structure Module \\
		& Equation Data Structure Module \\
		& Operator Data Structure Module \\
		\bottomrule
		
	\end{tabular}
	\caption{Module Hierarchy}
	\label{TblMH}
\end{table}

~\newpage

\section{MIS of the Control Flow Module} 
\label{Module_controlflow}
The Control Flow module is the only access point that external applications 
should use when implementing the Companion Cube Calculator. This affords the 
freedom to create any type of user interface without changing any of the 
underlying structure. In some cases, this means that a Control Flow access 
program simply returns the outputs from other module access programs without 
modifying them.

\subsection{Module}

ControlFlow

\subsection{Uses}

Input (Section~\ref{Module_userinput}), Consolidate 
(Section~\ref{Module_variableconsolidation}), Solver 
(Section~\ref{Module_rangesolver}), Output (Section~\ref{Module_output}),
IntervalStruct (Section~\ref{Module_intervaldatastructure}), EquationStruct 
(Section~\ref{Module_equationdatastructure})

\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{3.2cm} p{3cm} p{3cm} p{5cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
Initialize & - & $Boolean$ & - \\
ConditionRawInput & $String$, $Boolean$ & $String$ & - \\
ControlFile & $String$ & $String^n$ & - \\
ControlDirect & $String$, $String$ & $String^n$ & - \\
GetSuccessCode & - & $Int$ & - \\
GetValidFileTypes & - & $String^n$ & - \\
GetDelimiters & - & $String^2$ & - \\
ExtractVariables& $String$ & $String^n$ & - \\
GetVariableInfo & - & $String^{n \times 3}$ & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
	\item $hasRun$ : $Boolean$
	\item $successCode$ : $Int$
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent Initialize():
\begin{itemize}
	\item output: $out := success$ where $success$ is the output of the 
	Initialize access program from the Variable Consolidation module
	\item exception: N/A
\end{itemize}

\noindent ConditionRawInput($input, preserveSpecialChars$):
\begin{itemize}
	\item output: $out := conditionedLine$ where $conditioned$ is the output of 
	the RemoveWhitespace access program from the Input module
	\item exception: N/A
\end{itemize}

\noindent ControlFile(fileName):
\begin{itemize}
	\item output: $out := inputs$ where $inputs$ is the output of the 
	ReadFile access program from the Input module
	\item exception: N/A
\end{itemize}

\noindent ControlDirect($equationString, variableListString$):
\begin{itemize}
	\item transition: Updates the $successCode$ state variable with the return 
	value of the ConvertAndCheckInputs access program from the Consolidate 
	module. If the ControlDirect access program completes successfully, update 
	the $hasRun$ state variable to $True$.
	\item output: $out := results$ where:
	\begin{itemize}
		\item The program completed successfully:\\
		$results$ is the sequence $range, equationTree$. The value for $range$ 
		is the output of the PrintInterval access program from the Output 
		module and the value for $equationTree$ is the output of the 
		PrintEquationTree access program from the Output module.
		\item The program was not completed successfully, $results$ is $NULL$
	\end{itemize} 

	\begin{lstlisting}
	results = NULL
	successCode = Consolidate.ConvertAndCheckInputs(equationString, 
	   variableListString, 
	   Solver.GetValidOperators(), 
	   Solver.GetValidTerminators())
	if successCode = 0
	  range = Solver.FindRange(
	     Consolidate.GetEquationStruct(), 
	     Consolidate.GetIntervalStructList())
	  if range != NULL
	    results = {Output.PrintInterval(range), 
	               Output.PrintEquationTree(Consolidate.GetEquationStruct())}
	    hasRun = TRUE
	return results
	\end{lstlisting}
\end{itemize}

\noindent GetSuccessCode():
\begin{itemize}
	\item output: $out := successCode$
	\item exception: N/A
\end{itemize}

\noindent GetValidFileTypes():
\begin{itemize}
	\item output: $out := validFileTypes$ where $validFileTypes$ is the output 
	of the GetValidFileTypes access program from the Input module.
	\item exception: N/A
\end{itemize}

\noindent GetDelimiters():
\begin{itemize}
	\item output: $out := delimiters$ where $delimiters$ is the set of input 
	delimiters. The sequence size is two, where the first value is the output 
	of the GetLineDelimiter access program from the Input module and the second 
	value is the output of the GetFieldDelimiter access program from the Input 
	module. Both values in the sequence contain unescaped character sequences.
	\item exception: N/A
\end{itemize}

\noindent ExtractVariables():
\begin{itemize}
	\item output: $out := varList$ where $varList$ is the output of the 
	ExtractVariablesFromEquation access program from the Consolidate module.
	\item exception: N/A
\end{itemize}

\noindent GetVariableInfo():
\begin{itemize}
	\item output: $out := varInfoList$ where:
	\begin{lstlisting}
	Initialize varInfoList = NULL
	if hasRun is TRUE
	  intervalList = Consolidate.GetIntervalStructList()
	  if the interval list contains data
	    foreach(interval in intervalList)
	      varInfoList.Add(interval.GetVariableName, 
	                      interval.GetMinBound, 
                              interval.GetMaxBound)
    return varInfoList
	\end{lstlisting}
	\item exception: N/A
\end{itemize}

\newpage

\section{MIS of the User Input Module} 
\label{Module_userinput}
The Input Module is responsible for the File I/O and string formatting 
processes required by the program. This module simply outputs a pair of strings 
(equation and variable information) and leaves the conditioning and validation 
of the actual values to the Variable Consolidation Module 
(Section~\ref{Module_variableconsolidation}). This completely decouples input 
acquisition from files and the internal function of the program, allowing for 
other input methods to be implemented simultaneously while reducing the number 
of modules to modify if the underlying data structures 
(Section~\ref{Module_intervaldatastructure} and 
~\ref{Module_equationdatastructure}) change.

\subsection{Module}

Input

\subsection{Uses}

N/A

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
	\item $lineDelimiter$ : $String$
	\item $fieldDelimiter$ : $String$
	\item $validFileTypes$ : $String^n$
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3.3cm} p{3cm} p{3cm} p{5cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		\multirow{5}{3.3cm}{ReadFile} & \multirow{5}{3cm}{$String$} & 
		\multirow{5}{3cm}{$String^2$} & IN\_CANNOT\_READ\_FILE, \\
		 &  &  & IN\_EMPTY\_FILE, \\
		 & & & IN\_INVALID\_FILE\_TYPE,\\
		 & & &  IN\_NO\_EQUATION,\\
		 & & & IN\_NO\_FILE\\
		 RemoveWhitespace & $String$, $Bool$ & $String$ & - \\
		 GetLineDelimiter & - & $String$ & - \\
		 GetFieldDelimiter & - & $String$ & - \\
		 GetValidFileTypes & - & $String^n$ & - \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

N/A

\subsubsection{Assumptions}

\begin{itemize}
	\item Input files must be formatted such that:	
	\begin{itemize}
		\item The user equation is on the first line
		\item Each subsequent line contains the information (name, minimum 
		bound, and maximum bound) for variables. Each line contains one 
		variable definition, and each field in the variable definition is 
		separated by the $fieldDelimiter$.
	\end{itemize}
	The end of each line must be the value of $lineDelimiter$.
	\item The conditioning and validation of file contents is performed by the 
	Variable Consolidation module (Section~\ref{Module_variableconsolidation}).
\end{itemize}


\subsubsection{Access Routine Semantics}

\noindent ReadFile(fileName):
\begin{itemize}
	\item output: $out := fileContents$ where:
	\begin{itemize}
		\item $fileContents = \{fileName[0], fileName[1,fileName.Length]$ if no 
		exception was 
		raised
		\item $fileContents = NULL$ if an exception was raised
	\end{itemize}
	\item exception: $exc := \\
	(\neg Read(fileName) \Rightarrow IN\_CANNOT\_READ\_FILE)\\
	|\\
	(Read(fileName) == \emptyset \Rightarrow IN\_EMPTY\_FILE)\\
	|\\
	(fileName.Extension \notin validFileTypes \Rightarrow 
	IN\_INVALID\_FILE\_TYPE)\\
	|\\
	(fileName[0].Exists \wedge fileName[0].Contains(fieldDelimiter) \Rightarrow 
	IN\_NO\_EQUATION)\\
	|\\	
	(\neg fileName.Exists \Rightarrow IN\_NO\_FILE)$
\end{itemize}

\noindent RemoveWhitespace($line$, $preserveSpecialWhitespace$):
\begin{itemize}
	\item output: $out := conditionedLine$ where:
	\begin{itemize}
		\item If $preserveSpecialWhitespace = TRUE$, $conditionedLine = line$ 
		with white space characters removed except for carriage return 
		(\texttt{\textbackslash r}), line feed (\texttt{\textbackslash n}), and 
		horizontal tab (\texttt{\textbackslash t}) 
		characters
		\item If $preserveSpecialWhitespace = FALSE$, $conditionedLine = line$ 
		with all white space characters removed
	\end{itemize}
	\item exception: N/A
\end{itemize}

\noindent GetLineDelimiter():
\begin{itemize}
	\item output: $out := lineDelimiter$
	\item exception: N/A
\end{itemize}

\noindent GetFieldDelimiter():
\begin{itemize}
	\item output: $out := fieldDelimiter$
	\item exception: N/A
\end{itemize}

\noindent GetValidFileTypes():
\begin{itemize}
	\item output: $out := validFileTypes$
	\item exception: N/A
\end{itemize}

\newpage

\section{MIS of the Interval Conversion Module} 
\label{Module_intervalconversion}

\wss{Why even create the intermediate string form?  Why not go directly to the
  intervalStruct type?}

\subsection{Module}

IntervalConversion

\subsection{Uses}

IntervalStruct (Section~\ref{Module_intervaldatastructure})

\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3cm} p{2.3cm} p{3cm} p{5cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		\multirow{6}{3cm}{MakeInterval} & \multirow{6}{2.3cm}{$String^3$} & 
		\multirow{6}{3cm}{$intervalStruct$} & IVC\_EMPTY\_VARNAME, \\
		& & & IVC\_CONV\_ERR\_MIN, \\
		& & & IVC\_CONV\_ERR\_MAX, \\
		& & & IVC\_NO\_BOUNDS, \\
		& & & IVC\_NO\_MIN, \\
		& & & IVC\_NO\_MAX\\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

N/A

\subsubsection{Assumptions}

\begin{itemize}
	\item Ensuring that $min \leq max$ is handled by the IntervalStruct 
	(Section~\ref{Module_intervaldatastructure}) module.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent MakeInterval($varName, min, max$):
\begin{itemize}
	\item output: $out := newInterval$ \wss{Where is newInterval defined?}
	\item exception: $exc := \\
	(varName = ``" \Rightarrow IVC\_EMPTY\_VARNAME)\\
	|\\
	(ToReal(min) \notin \mathbb{R} \Rightarrow IVC\_CONV\_ERR\_MIN)\\
	|\\
	(ToReal(max) \notin \mathbb{R} \Rightarrow IVC\_CONV\_ERR\_MAX)\\
	|\\
	(min = max = ``" \Rightarrow IVC\_NO\_BOUNDS)\\
	|\\
	(min = ``" \wedge max \neq ``" \Rightarrow IVC\_NO\_MIN)\\
	|\\
	(min \neq ``" \wedge max = ``" \Rightarrow IVC\_NO\_MAX)$
\end{itemize}

\newpage

\section{MIS of the Equation Conversion Module} 
\label{Module_equationconversion}

\subsection{Module}

EquationConversion

\subsection{Uses}

EquationStruct (Section~\ref{Module_equationdatastructure}), OperatorStruct (Section~\ref{Module_operatordatastructure})

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
	\item $VARTOKEN : String$
	\item $CONSTTOKEN : String$
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3.2cm} p{2.8cm} p{3cm} p{5cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		\multirow{3}{3.2cm}{ConfigureParser} & 
		\multirow{3}{2.8cm}{$operatorStruct^n$, $String^{n\text{x}2}$} & 
		\multirow{3}{3cm}{$Boolean$} & EQC\_NO\_OPS, EQC\_INVALID\_OP, 
		EQC\_UNBALANCED\_TERMINATOR\\
		\multirow{4}{3.2cm}{MakeEquationTree} & \multirow{4}{2.8cm}{$String$} & 
		\multirow{4}{3cm}{$equationStruct$} & 
		EQC\_CONST\_FUNC, \\	
		& & & EQC\_IMPLICIT\_MULT, \\
		& & & EQC\_INCOMPLETE\_OP, \\
		& & & EQC\_UNSUPPORTED\_OP \\
		GetVariableToken & - & $String$ & - \\
		GetConstToken & - & $String$ & - \\
		GetVariableList & - & $String^n$ & - \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
	\item $variableList$ : $String^n$
	\item $variableStringPattern$ : $String$
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
	\item The ConfigureParser function will always be called before any other 
	function in this module.
	\item The MakeEquationTree function will always be called before the 
	GetVariableList function, otherwise it will not contain any data.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent ConfigureParser($operators, terminators$):
\begin{itemize}
	\item transition: The value of $variableStringPattern$ is updated so that 
	operators and terminators are not matched when the module is searching for 
	variables.
	\item output: $out := success$
	\item exception: $exc := \\
	(operators = \emptyset \Rightarrow EQC\_NO\_OPS)\\
	|\\
	(\exists op \in operators | op.IsUnary == False \wedge op.IsBinary == False 
	\Rightarrow EQC\_INVALID\_OP)\\
	|\\
	(\exists t[i][2] \in terminators | t[i][2] == "" \Rightarrow 
	EQC\_UNBALANCED\_TERMINATOR)$
\end{itemize}

\noindent MakeEquationTree($userEquation$):
\begin{itemize}
	\item transition: The value of $variableList$ is updated with new variable 
	names as they are encountered during equation processing.
	\item output: $out := equationTreeRoot$ \wss{Where is this output
            defined?  I would expect it to be defined in terms of the input parameters.}
	\item exception: $exc := \\
	(ToReal(userEquation) \in \mathbb{R} \Rightarrow EQC\_CONST\_FUNC)\\
	|\\
	(\exists subEq | subEq = \{subEq_1, subEq_2\} \wedge subEq_1 \in \mathbb{R} 
	\wedge subEq_2 \in variableList \\ \Rightarrow EQC\_IMPLICIT\_MULT)\\
	|\\
	(\exists op \in userEquation | (NULL<op>userEquation) \vee 
	(userEquation<op>NULL) \Rightarrow EQC\_INCOMPLETE\_OP)\\
	|\\
	(\exists op | op \in userEquation \wedge op \notin supportedOperations 
	\Rightarrow EQC\_UNSUPPORTED\_OP)$
\end{itemize}

\noindent GetVariableToken():
\begin{itemize}
	\item output: $out := VARTOKEN$
	\item exception: N/A
\end{itemize}

\noindent GetConstToken():
\begin{itemize}
	\item output: $out := CONSTTOKEN$
	\item exception: N/A
\end{itemize}

\noindent GetVariableList():
\begin{itemize}
	\item output: $out := variableList$
	\item exception: N/A
\end{itemize}

\newpage

\section{MIS of the Variable Consolidation Module} 
\label{Module_variableconsolidation}

\subsection{Module}

Consolidate

\subsection{Uses}

IntervalConversion (Section~\ref{Module_intervalconversion}), 
EquationConversion (Section~\ref{Module_equationconversion}), IntervalStruct 
(Section~\ref{Module_intervaldatastructure}), EquationStruct 
(Section~\ref{Module_equationdatastructure})


\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{4.3cm} p{2.7cm} p{3cm} p{4.3cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		\multirow{4}{4.3cm}{ConvertAndCheckInputs} & 
		\multirow{4}{2.3cm}{$String$, $String^n$, $operatorStruct^n$} & 
		\multirow{4}{3cm}{-} & VC\_MISSING\_VARS, \\
		& & & VC\_EXTRA\_VARS, \\
		& & & VC\_NO\_FUNCTION, \\
		& & & VC\_INVALID\_VARNAME \\
		GetEquationStruct & - & $equationStruct$ & - \\
		GetIntervalStructList & - & $intervalStruct^n$ & - \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
	\item $equationTreeRoot$ : $equationStruct$
	\item $intervalList$ : $intervalStruct^n$
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
	\item The ConvertAndCheckInputs function will change the state variables 
	before the GetEquationStruct or GetIntervalStructList functions are called.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent ConvertAndCheckInputs(eqString, varList, operators):
\begin{itemize}
	\item transition: The state variables $equationTreeRoot$ and $intervalList$ 
	will be assigned the values that result from a successful parse and 
	consolidation process. \wss{How is this done?  If you cannot represent
          it formally, maybe a pseudo code algorithm is available?}
	\item output: N/A 
	\item exception: $exc := \\
	(\exists var | var \in eqString \wedge var \notin varList \Rightarrow 
	VC\_MISSING\_VARS)\\
	|\\
	(\exists var | var \notin eqString \wedge var \in varList \Rightarrow 
	VC\_EXTRA\_VARS)\\
	|\\
	(eqString == ``" \Rightarrow VC\_NO\_FUNCTION)\\
	|\\
	(\exists varName \supset \{+, - , *, \, \string^, (, )\} \Rightarrow 
	VC\_INVALID\_VARNAME)$
\end{itemize}

\noindent GetEquationStruct():
\begin{itemize}
	\item output: $out := equationTreeRoot$
	\item exception: N/A
\end{itemize}

\noindent GetIntervalStructList():
\begin{itemize}
	\item output: $out := intervalList$ 
	\item exception: N/A
\end{itemize}

\newpage

\section{MIS of the Range Solver Module} 
\label{Module_rangesolver}

\subsection{Module}

Solver

\subsection{Uses}

IntervalStruct (Section~\ref{Module_intervaldatastructure}), EquationStruct 
(Section~\ref{Module_equationdatastructure}), OperatorStruct (Section~\ref{Module_operatordatastructure})

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
	\item $supportedOps : operatorStruct^n$
	\item $supportedTerminators : String^{n\text{x}2}$
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3.5cm} p{3cm} p{3cm} p{5cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		GetValidOperators & - & $operatorStruct^n$ & -\\
		GetValidTerminators & - & $String^{n\text{x}2}$ & -\\
		\multirow{2}{3.1cm}{FindRange} & $equationStruct$, $intervalStruct^n$ & 
		\multirow{2}{3cm}{$intervalStruct$} & 
		\multirow{2}{5cm}{SOL\_UNSUPPORTED\_OP}\\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

N/A

\subsubsection{Assumptions}

\begin{itemize}
	\item The type of $intervalStruct^n$ accepts \texttt{NULL} as a valid value.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent GetValidOperators():
\begin{itemize}
	\item output: $out := supportedOps$
	\item exception: N/A
\end{itemize}

\noindent GetValidTerminators():
\begin{itemize}
	\item output: $out := supportedTerminators$
	\item exception: N/A
\end{itemize}

\noindent FindRange($eStruct, ivStructList$):
\begin{itemize}
	\item output: $out := eqRange$
	\item exception: $exc := \\
	((\exists op \in eStruct \wedge op \notin supportedOps) \\
	\vee (\exists iv1, iv2 \in ivStructList \wedge \nexists op \in supportedOps 
	| op(iv1, iv2) \vee op(iv2, iv1)) \\
	\Rightarrow SOL\_UNSUPPORTED\_OP)$ 
\end{itemize}

\newpage

\section{MIS of the Output Module} 
\label{Module_output}
The Output module is responsible for converting data structures into 
output-friendly formats.

\subsection{Module}

Output

\subsection{Uses}

IntervalStruct (Section~\ref{Module_intervaldatastructure}), EquationStruct 
(Section~\ref{Module_equationdatastructure})

\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3.1cm} p{3cm} p{3cm} p{5cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		\multirow{2}{3.1cm}{PrintInterval} & $IntervalStruct$, $Boolean$ & 
		\multirow{2}{3cm}{$String$} & \multirow{2}{5cm}{-} \\
		PrintEquationTree & $equationStruct$ & $String$ & - \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

N/A

\subsubsection{Assumptions}

\begin{itemize}
	\item There are no exceptions in this module because it is assumed that 
	only well-formed inputs will be passed in. This assumption is made knowing 
	that this module will only be called post-process and any errors in the 
	data structures have already been identified.
	\item The object passed to PrintEquationTree is the root of the equation 
	tree.
\end{itemize}


\subsubsection{Access Routine Semantics}

\noindent PrintInterval($interval, withVarName$):
\begin{itemize}
	\item output: $out := formattedInterval$ where $formattedInterval$ is a 
	string corresponding the fields in $interval$:
	\begin{itemize}
		\item If $interval$ is a constant value, $formattedInterval$ is 
		$CONST:$ with the value appended
		\item Otherwise:
		\begin{itemize}
			\item If $withVarName$ is true, the $formattedInterval$ begins with 
			the interval's variable name and `` = "
			\item If $interval$ is closed on the left boundary, append ``$[$" 
			to $formattedInterval$; otherwise, append ``$($"
			\item Append the minimum and maximum boundary values from 
			$interval$ 
			separated by a comma (``,"); if the minimum bound has more that 12 
			values, put the maximum boundary value on a new line
			\item If $interval$ is closed on the right boundary, append $]$ to 
			$formattedInterval$; otherwise, append $)$
		\end{itemize}
	\end{itemize}
	\item exception: N/A
\end{itemize}

\noindent PrintEquationTree($eqRoot$):
\begin{itemize}
	\item output: $out := formattedTree$ where $formattedTree$ is a 
	string corresponding the formatted $eqRoot$:
	\begin{itemize}
		\item If $eqRoot$ is a variable, append $+- \{VAR\}$ and the variable 
		name
		\item If $eqRoot$ is a constant, append $+- \{CONST\}$ and the value
		\item If $eqRoot$ is an operator node, append $+- \{<op>\}$ where $op$ 
		is 
		the node operator:
		\item If $eqRoot$ is a right operand and has no left of right 
		operands of its own, append ``   "; this will align the tree levels
		\item If $eqRoot$ is not a right operator or has a left or right 
		operand, append ``\textbar ";  this will align the tree levels
		\item Append a new line character and print the trees corresponding 
		to the left and right operands of $eqRoot$ if they exist
	\end{itemize}
	\item exception: N/A
\end{itemize}

\newpage

\section{MIS of the Interval Data Structure Module} 
\label{Module_intervaldatastructure}
The Interval Data Structure represents a mathematical interval with end points 
$minBound$ and $maxBound$. This implementation is designed to be application 
dependant.

\subsection{Module}

IntervalStruct

\subsection{Uses}

N/A

\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3.8cm} p{2.5cm} p{3cm} p{5cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline		
		IntervalStruct & $String$, $\mathbb{R}^2$, $Boolean^2$ & 
		$IntervalStruct$ & 
		IV\_ORD\_VIOLATED \\
		GetVariableName & - & $String$ & - \\
		GetMinBound & - & $\mathbb{R}$ & - \\
		GetMaxBound & - & $\mathbb{R}$ & - \\
		IsLeftBoundClosed & - & $Boolean$ & - \\
		IsRightBoundClosed & - & $Boolean$ & - \\
		SetVariableName & $String$ & - & - \\
		SetMinBound & $\mathbb{R}$ & - & IV\_MIN\_ORD\_VIOLATED \\
		SetMaxBound & $\mathbb{R}$ & - & IV\_MAX\_ORD\_VIOLATED \\
		SetLeftBoundClosed & $Boolean$ & - & - \\
		SetRightBoundClosed & $Boolean$ & - & - \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\# For \rref{R_conditionX} using \ddref{DD_interval}
\begin{itemize}
	\item $variableName$ : $String$
	\item $minBound : \mathbb{R}$
	\item $maxBound : \mathbb{R}$
	\item $isClosedLeft : Boolean$
	\item $isClosedRight : Boolean$
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent IntervalStruct($varName, minB, maxB, leftClosed, RightClosed$):
\begin{itemize}
	\item output: $out := new IntervalStruct(variableName$, $minBound$, 
	$maxBound$, $isClosedLeft$, $isClosedRight)$
	\item transition: Update state variables $variableName$, $minBound$, 
	$maxBound$, $isClosedLeft$, and $isClosedRight$ with the provided values 
	$varName$, $minB$, $maxB$, $leftClosed$, and $rightClosed$
	\item exception: $exc := \\
	(minB > maxB \Rightarrow IV\_ORD\_VIOLATED)$
\end{itemize}

\noindent GetVariableName():
\begin{itemize}
	\item output: $out := variableName$
	\item exception: N/A
\end{itemize}

\noindent GetMinBound():
\begin{itemize}
	\item output: $out := minBound$
	\item exception: N/A
\end{itemize}

\noindent GetMaxBound():
\begin{itemize}
	\item output: $out := maxBound$
	\item exception: N/A
\end{itemize}

\noindent IsLeftBoundClosed():
\begin{itemize}
	\item output: $out := isClosedLeft$
	\item exception: N/A
\end{itemize}

\noindent IsRightBoundClosed():
\begin{itemize}
	\item output: $out := isClosedRight$
	\item exception: N/A
\end{itemize}

\noindent SetVariableName($varName$):
\begin{itemize}
	\item transition: Update state variable $variableName$ with the provided 
	value $varName$
	\item exception: N/A
\end{itemize}

\noindent SetMinBound($minB$):
\begin{itemize}
	\item transition: Update state variable $minBound$ with the provided value 
	$minB$
	\item exception: $exc := \\
	(minB > maxBound \Rightarrow IV\_MIN\_ORD\_VIOLATED)$
\end{itemize}

\noindent SetMaxBound($maxB$):
\begin{itemize}
	\item transition: Update state variable $maxBound$ with the provided value 
	$maxB$
	\item exception: $exc := \\
	(maxB < minBound \Rightarrow IV\_MAX\_ORD\_VIOLATED)$
\end{itemize}

\noindent SetLeftBoundClosed($closed$):
\begin{itemize}
	\item transition: Update state variable $isClosedLeft$ with the provided 
	value $closed$
	\item exception: N/A
\end{itemize}

\noindent SetRightBoundClosed($closed$):
\begin{itemize}
	\item transition: Update state variable $isClosedRight$ with the provided 
	value $closed$
	\item exception: N/A
\end{itemize}

\newpage

\section{MIS of the Equation Data Structure Module} 
\label{Module_equationdatastructure}
The Equation Data Structure represents a node in an equation tree which can 
support up to two-operand operations. The tree can be expanded by assigning 
other nodes as the left and right operands.

\subsection{Module}

EquationStruct

\subsection{Uses}

N/A

\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3cm} p{3cm} p{3cm} p{5cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		\multirow{2}{3cm}{EquationStruct} & $String^2$, $EquationStruct^2$ & 
		\multirow{2}{3cm}{$EquationStruct$} & 
		\multirow{2}{5cm}{EQS\_MISSING\_OP}\\
		GetOperator & - & $String$ & - \\
		GetVariableName & - & $String$ & - \\
		GetLeftOperand & - & $EquationStruct$ & -\\
		GetRightOperand & - & $EquationStruct$ & - \\
		SetVariableName & $String$ & - & - \\
		SetLeftOperand & $EquationStruct$ & - & - \\
		SetRightOperand & $EquationStruct$ & - & - \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\# To support \rref{R_conditionfx} and \rref{R_CalculateCompose}
\begin{itemize}
	\item $operatr : String$
	\item $variableName : String$
	\item $leftOperand : EquationStruct$
	\item $rightOperand : EquationStruct$
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
	\item The decomposition of the user equation is handled by the Equation 
	Conversion module (Section~\ref{Module_equationconversion}).
	\item Unsupported operators are identified and handled in the Equation 
	Conversion module (Section~\ref{Module_equationconversion}).
	\item There is no setter method for the $operator$ field because they will 
	not be changed after initialization.
	\item The values for $leftOperand$ and $rightOperand$ can be set to 
	\texttt{NULL} as required (e.g. variables, constants).
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent EquationStruct($op, vName, eStruct1, eStruct2$):
\begin{itemize}
	\item output: $out := new EquationStruct(operatr$, $variableName$, 
	$leftOperand$, $rightOperand)$
	\item transition: Update state variables $operatr$, $variableName$, 
	$leftOperand$, and $rightOperand$ with the provided values $op$, $vName$, 
	$eStruct1,$ and $eStruct2$
	\item exception: $exc := \\
	(op = ``" \Rightarrow EQS\_MISSING\_OP)$
\end{itemize}

\noindent GetOperator():
\begin{itemize}
	\item output: $out := operatr$
	\item exception: N/A
\end{itemize}

\noindent GetVariableName():
\begin{itemize}
	\item output: $out := variableName$
	\item exception: N/A
\end{itemize}

\noindent GetLeftOperand():
\begin{itemize}
	\item output: $out := leftOperand$
	\item exception: N/A
\end{itemize}

\noindent GetRightOperand():
\begin{itemize}
	\item output: $out := rightOperand$
	\item exception: N/A
\end{itemize}

\noindent SetVariableName($vName$):
\begin{itemize}
	\item transition: Update state variable $variableName$ with the provided 
	value $vName$
	\item exception: N/A
\end{itemize}

\noindent SetLeftOperand($eStruct$):
\begin{itemize}
	\item transition: Update state variable $leftOperand$ with the provided 
	value $eStruct$
	\item exception: N/A
\end{itemize}

\noindent SetRightOperand($eStruct$):
\begin{itemize}
	\item transition: Update state variable $rightOperand$ with the provided 
	value $eStruct$
	\item exception: N/A
\end{itemize}

\newpage

\section{MIS of the Operator Data Structure Module} 
\label{Module_operatordatastructure}
The Operator Data Structure contains all relevant information required to 
correctly use them in a mathematical context. It is much simpler to pass a 
single data structure containing all of the associated fields for an operator 
as opposed to creating a class with lists of information that must queried and 
returned individually for each associated operator field.

\subsection{Module}

OperatorStruct

\subsection{Uses}

N/A

\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3cm} p{3cm} p{3cm} p{5cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		\multirow{4}{3cm}{OperatorStruct} & \multirow{4}{3cm}{$String$, $Int$, 
		$Boolean^4$} & \multirow{4}{3cm}{$OperatorStruct$} & 
		OP\_INVALID\_PRECEDENCE, OP\_MISSING\_OP, 
		OP\_MULTI\_TYPE, OP\_NO\_TYPE\\
		GetOperator & - & $String$ & - \\
		GetPrecedence & - & $Int$ & - \\
		IsUnary & - & $Boolean$ & - \\
		IsBinary & - & $Boolean$ & - \\
		IsTernary & - & $Boolean$ & - \\
		IsLeftAssociative & - & $Boolean$ & -\\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
	\item $operatr : String$
	\item $precedence : Int$
	\item $isUnary : Boolean$
	\item $isBinary : Boolean$
	\item $isTernary : Boolean$
	\item $leftAssociative : Boolean$
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
	\item There are no Setter methods for this module because operator properties are fixed.
	\item A high integer value is associated with a high precedence operation.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent OperatorStruct($op, prec, isUnary, isBinary, isTernary, isLeftAssociative$):
\begin{itemize}
	\item output: $out := new OperatorStruct(operatr$, $precedence$, $isUnary$, 
	$isBinary$, $isTernary$, $leftAssociative)$
	\item transition: Update state variables $operatr$, $precedence$, 
	$isUnary$, $isBinary$, $isTernary$, and $leftAssociative$ with the provided 
	values $op$, $prec$, $isUnary$, $isBinary$, $isTernary$, and 
	$isLeftAssociative$.
	\item exception: $exc := \\
	(prec < 0 \Rightarrow OP\_INVALID\_PRECEDENCE)\\
	|\\
	(op = ``" \Rightarrow OP\_MISSING\_OP)\\
	|\\
	((isUnary = isBinary \wedge isUnary = True) \vee (isUnary = isTernary 
	\wedge isUnary = True) \vee (isBinary = isTernary \wedge isBinary = True) 
	\Rightarrow OP\_MULTI\_TYPE)\\
	|\\
	(isUnary = isBinary = isTernary \wedge isUnary = False \Rightarrow 
	OP\_NO\_TYPE)$
\end{itemize}

\noindent GetOperator():
\begin{itemize}
	\item output: $out := operatr$
	\item exception: N/A
\end{itemize}

\noindent GetPrecedence():
\begin{itemize}
	\item output: $out := precedence$
	\item exception: N/A
\end{itemize}

\noindent IsUnary():
\begin{itemize}
	\item output: $out := isUnary$
	\item exception: N/A
\end{itemize}

\noindent IsBinary():
\begin{itemize}
	\item output: $out := isBinary$
	\item exception: N/A
\end{itemize}

\noindent IsTernary():
\begin{itemize}
	\item output: $out := isTernary$
	\item exception: N/A
\end{itemize}

\noindent IsLeftAssociative():
\begin{itemize}
	\item output: $out := leftAssociative$
	\item exception: N/A
\end{itemize}

\newpage

\bibliographystyle {plainnat}
\bibliography {../../../ReferenceMaterial/References}

\newpage

\section{Appendix} \label{Appendix}

\renewcommand{\arraystretch}{1.2}

\begin{longtable}{l p{9.5cm}}
	\caption{Possible Error Exceptions} \\
	\toprule
	\textbf{Message ID} & \textbf{Error Message} \\
	\midrule
	EQC\_NO\_OPS & Error: No operators were passed to the equation conversion 
	module. \\ 
	EQC\_INVALID\_OP & Error: The equation conversion module cannot parse the 
	passed operator. \\ 
	EQC\_UNBALANCED\_TERMINATOR & Error: An unbalanced terminator was passed to 
	the equation conversion module.\\
	EQC\_UNSUPPORTED\_OP & Error: The user equation contains an unsupported 
	operator. Supported operators include $<supportedOperators>$.\\
	EQC\_INCOMPLETE\_OP & Error: An operator was found that does not have 
	sufficient operands. \\
	EQS\_MISSING\_OP & Error: Equation structures must be assigned an operator 
	during initialization. \\
	IN\_CANNOT\_READ\_FILE & Error: The file could not be read. \\	
	IN\_EMPTY\_FILE & Error: The file is empty. \\
	IN\_INVALID\_FILE\_TYPE & Error: Cannot read files of this type. \\
	IN\_NO\_EQUATION & Error: The first line of the file is not an equation or 
	the equation contains $<Input.GetFieldDelimiter>$.\\
	IN\_NO\_FILE & Error: The specified file does not exist. \\ 
	IVC\_CONV\_ERR\_MIN & Error: The string provided for the minimum bound 
	cannot be converted to a real number. \\
	IVC\_CONV\_ERR\_MAX & Error: The string provided for the maximum bound 
	cannot be converted to a real number.\\
	IVC\_EMPTY\_VARNAME & Error: Intervals must have an associated variable 
	name. \\
	IVC\_NO\_BOUNDS & Error: No values provided for either interval bound. \\
	OP\_INVALID\_PRECEDENCE & Error: Cannot assign a precedence value less than 
	0.\\
	OP\_MISSING\_OP & Error: Cannot have an operator with no representative symbol. \\
	OP\_MULTI\_TYPE & Error: An operator cannot be overloaded to be unary, 
	binary, and ternary. \\
	OP\_NO\_TYPE & Error: Operators must be assigned a number of operands type. 
	\\
	SOL\_UNSUPPORTED\_OP & Error: An unsupported operation was encountered 
	while solving for the range of the equation.\\
	VC\_INVALID\_VARNAME & Error: Encountered a variable name with reserved 
	characters ($+, - , *, \, \string^, (, )$). \\
	VC\_MISSING\_VARS & Error: A variable is referenced in the user equation 
	that does not exist in the variable list. \\
	VC\_NO\_FUNC & Error: No user equation was received. \\
	\bottomrule
\end{longtable}


\begin{longtable}{l p{9.5cm}}
	\caption{Possible Warning Exceptions} \\
	\toprule
	\textbf{Message ID} & \textbf{Error Message} \\
	\midrule
	EQ\_WRONG\_OPERATOR\_TYPE & Warning: The operator must have type $string$. 
	String type conversion has been applied.\\
	EQ\_WRONG\_VARNAME\_TYPE & Warning: The variable name must have type 
	$string$. String type conversion has been applied. \\
	EQC\_CONST\_FUNC & Warning: The user equation is a constant value and the 
	range will only include this value.\\
	EQC\_IMPLICIT\_MULT & Warning: Encountered an implicit multiplication of a 
	constant value and a variable. Expanding with explicit operator. \\
	IV\_MIN\_ORD\_VIOLATED & WARNING: Value provided for minimum bound is 
	greater than the current maximum bound. The values have been exchanged to 
	maintain the interval ordering. \\
	IV\_MAX\_ORD\_VIOLATED & WARNING: Value provided for maximum bound is 
	smaller than the current minimum bound. The values have been exchanged to 
	maintain the interval ordering. \\
	IV\_ORD\_VIOLATED & Warning: Value provided for intervals are not in 
	increasing order. The values have been exchanged to maintain the interval 
	ordering. \\
	IVC\_NO\_MIN & Warning: No minimum interval bound given. Setting it to the 
	same value as the maximum bound. \\
	IVC\_NO\_MAX & Warning: No maximum interval bound given. Setting it to the 
	same value as the minimum bound. \\
	VC\_EXTRA\_VARS & Warning: There are more variables in the variable list 
	than the user equation. Extraneous variables will be ignored. \\
	\bottomrule
\end{longtable}

\end{document}