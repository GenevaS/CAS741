\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[usenames,dvipsnames,table]{xcolor}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}
\usepackage{listings}

\lstset{ %
	breaklines = true
}

\externaldocument{../../SRS/SRS}
\newcommand{\rref}[1]{R\ref{#1}}
\newcommand{\ddref}[1]{DD\ref{#1}}

\hypersetup{
	bookmarks=true,     % show bookmarks bar?
	colorlinks=true,       % false: boxed links; true: colored links
	citecolor=ForestGreen,
	filecolor=WildStrawberry,
	linkcolor=Purple,
	urlcolor=Cerulean      % color of external links
}

\usepackage{array}

\input{../../Comments}

\newcommand{\progname}{Companion Cube Calculator}
\newcommand{\prognameAbbrv}{$C^{3}$}

\begin{document}

\title{Module Interface Specification for the \progname{} (\prognameAbbrv{})}

\author{Geneva Smith}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
 & 1.0 & Initial draft completed\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See SRS Documentation at 
\url{https://github.com/GenevaS/CAS741/tree/master/Doc/SRS} for project 
symbols, abbreviations, and acronyms.

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for the 
\progname{} (\prognameAbbrv{}), a mathematical tool which determines the range 
of a user-specified function given the domains of the function's variables. The 
calculations are performed using interval arithmetic.

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at \url{https://github.com/GenevaS/CAS741}.

\section{Notation}

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \progname. 

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
Real & $\mathbb{R}$ & Any number in (-$\infty$, $\infty$)\\
\multirow{2}{1cm}{String} & \multirow{2}{1cm}{$char^n$} & A sequence of 
alphanumeric and special characters\\
\bottomrule
\end{tabular} 
\end{center}

\noindent
The specification of \progname \ uses some derived data types: sequences, strings, and
tuples. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \progname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.

\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this 
project. It can be found at 
\url{https://github.com/GenevaS/CAS741/blob/master/Doc/Design/MG}.

\begin{table}[h!]
	\centering
	\begin{tabular}{p{0.35\textwidth} p{0.6\textwidth}}
		\toprule
		\textbf{Level 1} & \textbf{Level 2}\\
		\midrule
		
		{Hardware-Hiding Module} & - \\
		\midrule
		
		\multirow{7}{0.29\textwidth}{Behaviour-Hiding Module} & Control Flow 
		Module \\
		& User Input Module \\
		& Interval Conversion Module \\
		& Equation Conversion Module \\
		& Variable Consolidation Module \\
		& Range Solver Module \\
		& Output Module \\
		\midrule
		
		\multirow{2}{0.29\textwidth}{Software Decision Module} & Interval Data 
		Structure Module \\
		& Equation Data Structure Module \\
		\bottomrule
		
	\end{tabular}
	\caption{Module Hierarchy}
	\label{TblMH}
\end{table}

\newpage
~\newpage

\section{MIS of the Control Flow Module} 
\label{Module_controlflow}

\subsection{Module}

main

\subsection{Uses}

Input (Section~\ref{Module_userinput}), Consolidate 
(Section~\ref{Module_variableconsolidation}), Solver 
(Section~\ref{Module_rangesolver}), Output (Section~\ref{Module_output}), 
IntervalStruct (Section~\ref{Module_intervaldatastructure}), EquationStruct 
(Section~\ref{Module_equationdatastructure})


\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{3cm} p{3cm} p{3cm} p{5cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
Main & - & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

N/A

\subsubsection{Access Routine Semantics}

\noindent Main():
\begin{itemize}
\item transition: Create data structures to contain the user inputs and modify 
their states for the Output module.
\end{itemize}

\begin{lstlisting}
# Get User Input
  userInputs := Input.GetUserInputs()
  eqString := userInputs[0]
  varList := userInputs[1, userInputs.Length - 1]    
 
# Convert input into equation and interval data structures using 
# the list of valid operators from Solver
  operators := Solver.GetValidOperators()
  Consolidate.ConvertAndCheckInputs(eqString, varList, operators)
  
# Get the equation and interval data structures and pass them to 
# the Solver module
  equationData := Consolidate.GetEquationStruct()
  intervalDataList := Consolidate.GetIntervalStructList()
  range := Solver.CalculateRange(equationData, intervalDataList)
  
# Report the results back to the user
  Output.PrintInterval(range)
  Output.PrintEquationTree(equationData)
  for each interval in intervalDataList:
    Output.PrintInterval(interval)
\end{lstlisting}

\newpage

\section{MIS of the User Input Module} 
\label{Module_userinput}

\subsection{Module}

Input

\subsection{Uses}

N/A

\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3cm} p{3cm} p{3cm} p{5cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		\multirow{2}{3cm}{GetUserInputs} & \multirow{2}{3cm}{-} & 
		\multirow{2}{3cm}{$String^n$} & IN\_BAD\_FILE, \\
		 &  &  & IN\_EMPTY\_FILE \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{Environment Variables}

$inputFile$ : $String^n$

\subsubsection{State Variables}

N/A

\subsubsection{Assumptions}

\begin{itemize}
	\item The GetInputMethod function accepts user inputs from files or as 
	direct inputs (From SRS \rref{R_Inputs}).
	
	\item If the user chooses to enter their values via a file, it must be 
	formatted such that:	
	\begin{itemize}
		\item The user equation on the first line
		\item The list of variable names and interval values associated with 
		the user equation; each name/value set is on its own line and is of the 
		form $varName, minBound$, $maxBound$
	\end{itemize}

	\item The output of the GetUserInputs function is a list of $String$ where 
	the first item is the user equation. The remaining items are the variable 
	names and interval values such that every set of three values represents 
	one data set. 
\end{itemize}


\subsubsection{Access Routine Semantics}

\noindent GetUserInputs():
\begin{itemize}
	\item transition: If the user has chosen to enter their values via a file, 
	$inputFile$ is associated with the provided file name.
	\item output: $out := eqString || varList$
	\item exception: $exc := \\
	(\nexists inputFile \vee \neg Read(inputFile) \Rightarrow IN\_BAD\_FILE)\\
	|\\
	(Read(inputFile) == \emptyset \Rightarrow IN\_EMPTY\_FILE)$
\end{itemize}

\newpage

\section{MIS of the Interval Conversion Module} 
\label{Module_intervalconversion}

\subsection{Module}

IntervalConversion

\subsection{Uses}

IntervalStruct (Section~\ref{Module_intervaldatastructure})

\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3cm} p{4cm} p{4cm} p{2cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		\multirow{4}{3cm}{MakeInterval} & \multirow{4}{3cm}{$String^2$} & 
		\multirow{4}{3cm}{$intervalStruct$} & IVC\_CONV\_ERR\_MIN, \\
		& & & IVC\_CONV\_ERR\_MAX, \\
		& & & IVC\_NO\_MIN, \\
		& & & IVC\_NO\_MAX,\\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

N/A

\subsubsection{Assumptions}

\begin{itemize}
	\item Ensuring that $min \leq max$ is handled by the IntervalStruct 
	(Section~\ref{Module_intervaldatastructure}) module.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent MakeInterval($min, max$):
\begin{itemize}
	\item output: $out := newInterval$
	\item exception: $exc := \\
	(ToReal(min) \notin \mathbb{R} \Rightarrow IVC\_CONV\_ERR\_MIN)\\
	|\\
	(ToReal(max) \notin \mathbb{R} \Rightarrow IVC\_CONV\_ERR\_MAX)\\
	|\\
	(min == ``" \Rightarrow IVC\_NO\_MIN)\\
	|\\
	(max == ``" \Rightarrow IVC\_NO\_MAX)$
\end{itemize}

\newpage

\section{MIS of the Equation Conversion Module} 
\label{Module_equationconversion}

\subsection{Module}

EquationConversion

\subsection{Uses}

EquationStruct (Section~\ref{Module_equationdatastructure})

\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3.2cm} p{2.8cm} p{3cm} p{5cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		\multirow{4}{3.2cm}{MakeEquationTree} & \multirow{4}{2.8cm}{$String$, 
		$String^n$} & \multirow{4}{3cm}{$equationStruct$} & 
		EQC\_CONST\_FUNC, \\	
		& & & EQC\_IMPLICIT\_MULT, \\
		& & & EQC\_INCOMPLETE\_OP, \\
		& & & EQC\_UNSUPPORTED\_OP \\
		GetVariableList & - & $String^n$ & - \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
	\item $variableList$ : $String^n$
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent MakeEquationTree($userEquation, supportedOperations$):
\begin{itemize}
	\item transition: The value of $variableList$ is updated with new variable 
	names as they are encountered during equation processing.
	\item output: $out := equationTreeRoot$
	\item exception: $exc := \\
	(ToReal(userEquation) \in \mathbb{R} \Rightarrow EQC\_CONST\_FUNC)\\
	|\\
	(\exists subEq | subEq = \{subEq_1, subEq_2\} \wedge subEq_1 \in \mathbb{R} 
	\wedge subEq_2 \in variableList \\ \Rightarrow EQC\_IMPLICIT\_MULT)\\
	|\\
	(\exists op \in userEquation | (NULL<op>userEquation) \vee 
	(userEquation<op>NULL) \Rightarrow EQC\_INCOMPLETE\_OP)\\
	|\\
	(\exists op | op \in userEquation \wedge op \notin supportedOperations 
	\Rightarrow EQC\_UNSUPPORTED\_OP)$
\end{itemize}

\noindent GetVariableList():
\begin{itemize}
	\item output: $out := variableList$
	\item exception: N/A
\end{itemize}

\newpage

\section{MIS of the Variable Consolidation Module} 
\label{Module_variableconsolidation}

\subsection{Module}

Consolidate

\subsection{Uses}

IntervalConversion (Section~\ref{Module_intervalconversion}), 
EquationConversion (Section~\ref{Module_equationconversion}), IntervalStruct 
(Section~\ref{Module_intervaldatastructure}), EquationStruct 
(Section~\ref{Module_equationdatastructure})


\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{4.3cm} p{2.3cm} p{3cm} p{5cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		\multirow{4}{4.3cm}{ConvertAndCheckInputs} & 
		\multirow{4}{2.3cm}{$String$, $String^n$, $String^n$} & 
		\multirow{4}{3cm}{-} & VC\_MISSING\_VARS, \\
		& & & VC\_EXTRA\_VARS, \\
		& & & VC\_NO\_FUNCTION, \\
		& & & VC\_INVALID\_VARNAME \\
		GetEquationStruct & - & $equationStruct$ & - \\
		GetIntervalStructList & - & $intervalStruct^n$ & - \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
	\item $equationTreeRoot$ : $equationStruct$
	\item $intervalList$ : $intervalStruct^n$
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
	\item The ConvertAndCheckInputs function will change the state variables 
	before the GetEquationStruct or GetIntervalStructList functions are called.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent ConvertAndCheckInputs(eqString, varList, operators):
\begin{itemize}
	\item transition: The state variables $equationTreeRoot$ and $intervalList$ 
	will be assigned the values that result from a successful parse and 
	consolidation process. 
	\item output: N/A 
	\item exception: $exc := \\
	(\exists var | var \in eqString \wedge var \notin varList \Rightarrow 
	VC\_MISSING\_VARS)\\
	|\\
	(\exists var | var \notin eqString \wedge var \in varList \Rightarrow 
	VC\_EXTRA\_VARS)\\
	|\\
	(eqString == ``" \Rightarrow VC\_NO\_FUNCTION)\\
	|\\
	(\exists varName \supset \{+, - , *, \, \string^, (, )\} \Rightarrow 
	VC\_INVALID\_VARNAME)$
\end{itemize}

\noindent GetEquationStruct():
\begin{itemize}
	\item output: $out := equationTreeRoot$
	\item exception: N/A
\end{itemize}

\noindent GetIntervalStructList():
\begin{itemize}
	\item output: $out := intervalList$ 
	\item exception: N/A
\end{itemize}

\newpage

\section{MIS of the Range Solver Module} 
\label{Module_rangesolver}

\subsection{Module}

Solver

\subsection{Uses}

IntervalStruct (Section~\ref{Module_intervaldatastructure}), EquationStruct 
(Section~\ref{Module_equationdatastructure})

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
	\item $supportedOps : String^n$
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3.1cm} p{3cm} p{3cm} p{5cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		GetValidOperators & - & $String^n$ & -\\
		\multirow{4}{3.1cm}{FindRange} &  & 
		\multirow{4}{3.1cm}{$intervalStruct$} & SOL\_INSUFF\_PARAMS,\\
		& $equationStruct$, & & SOL\_WRONG\_EQ\_TYPE,\\
		& $intervalStruct^n$ & & SOL\_WRONG\_IV\_TYPE,\\
		& & & SOL\_UNSUPPORTED\_OP\\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

N/A

\subsubsection{Assumptions}

\begin{itemize}
	\item The type of $intervalStruct^n$ accepts \texttt{NULL} as a valid value.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent GetValidOperators():
\begin{itemize}
	\item output: $out := supportedOps$
	\item exception: N/A
\end{itemize}

\noindent FindRange($eStruct, ivStructList$):
\begin{itemize}
	\item output: $out := intervalStruct$
	\item exception: $exc := \\
	(\nexists eStruct \vee \nexists ivStructList \Rightarrow 
	SOL\_INSUFF\_PARAMS)\\
	|\\
	(eStruct \neq equationStruct \Rightarrow SOL\_WRONG\_EQ\_TYPE) \\
	|\\
	(ivStructList \neq intervalStruct^n \vee ivStructList \neq NULL 
	\\\Rightarrow SOL\_WRONG\_IV\_TYPE) \\
	|\\
	((\exists op \in eStruct \wedge op \notin supportedOps) \\
	\vee (\exists iv1, iv2 \in ivStructList \wedge \nexists op \in supportedOps 
	| op(iv1, iv2) \vee op(iv2, iv1)) \\
	\Rightarrow UNSUPPORTED\_OP)$ 
\end{itemize}

\newpage

\section{MIS of the Output Module} 
\label{Module_output}

\subsection{Module}

Output

\subsection{Uses}

IntervalStruct (Section~\ref{Module_intervaldatastructure}), EquationStruct 
(Section~\ref{Module_equationdatastructure})

\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3.1cm} p{3cm} p{3cm} p{5cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		PrintInterval & $intervalStruct$ & - & - \\
		PrintEquationTree & $equationStruct$ & - & - \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

N/A

\subsubsection{Environment Variables}

\begin{itemize}
	\item cmd: the command-line interface
	\item win: a 2D sequence of pixels displayed on the screen
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
	\item There are no exceptions in this module because it is assumed that 
	only well-formed inputs will be passed in. This assumption is made knowing 
	that this module will only be called post-process and any errors in the 
	data structures have already been identified.
	\item The object passed to PrintEquationTree is the root of the equation 
	tree
\end{itemize}


\subsubsection{Access Routine Semantics}

\noindent PrintIntervalList($iStruct$):
\begin{itemize}
	\item transition: If the user interface is the command-line, write the 
	interval $iStruct$ to cmd. If the user interface is a GUI, modify win so 
	that the interval is displayed. In both cases, the variable name of the 
	interval must also be displayed.
	\item exception: N/A
\end{itemize}

\noindent PrintEquationTree($eStruct$):
\begin{itemize}
	\item transition: If the user interface is the command-line, write the 
	equation tree represented by $eStruct$ to cmd. If the user interface is a 
	GUI, modify win so that the equation tree is displayed.
	\item exception: N/A
\end{itemize}

\newpage

\section{MIS of the Interval Data Structure Module} 
\label{Module_intervaldatastructure}

\subsection{Module}

IntervalStruct

\subsection{Uses}

N/A

\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3cm} p{3cm} p{3cm} p{5cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline		
		IntervalStruct & $\mathbb{R}^2$ & $intervalStruct$ & IV\_ORD\_VIOLATED 
		\\
		GetMinBound & - & $\mathbb{R}$ & - \\
		GetMaxBound & - & $\mathbb{R}$ & - \\
		SetMinBound & $\mathbb{R}$ & - & IV\_ORD\_VIOLATED \\
		SetMaxBound & $\mathbb{R}$ & - & IV\_ORD\_VIOLATED \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\# For \rref{R_conditionX} using \ddref{DD_interval}
\begin{itemize}
	\item $minBound : \mathbb{R}$
	\item $maxBound : \mathbb{R}$
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent IntervalStruct($minB, maxB$):
\begin{itemize}
	\item output: $out := intervalStruct(minB, maxB)$
	\item transition: Update state variables $minBound$ and $maxBound$ with the 
	provided values $minB$ and $maxB$
	\item exception: $exc := \\
	(minB > maxB \Rightarrow IV\_ORD\_VIOLATED)$
\end{itemize}

\noindent GetMinBound():
\begin{itemize}
	\item output: $out := minBound$
	\item exception: N/A
\end{itemize}

\noindent GetMaxBound():
\begin{itemize}
	\item output: $out := maxBound$
	\item exception: N/A
\end{itemize}

\noindent SetMinBound($minB$):
\begin{itemize}
	\item transition: Update state variable $minBound$ with the provided value 
	$minB$
	\item exception: $exc := \\
	(minB > maxBound \Rightarrow IV\_ORD\_VIOLATED)$
\end{itemize}

\noindent SetMaxBound($maxB$):
\begin{itemize}
	\item transition: Update state variable $maxBound$ with the provided value 
	$maxB$
	\item exception: $exc := \\
	(maxB < minBound \Rightarrow IV\_ORD\_VIOLATED)$
\end{itemize}

\newpage

\section{MIS of the Equation Data Structure Module} 
\label{Module_equationdatastructure}

\subsection{Module}

EquationStruct

\subsection{Uses}

N/A

\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3cm} p{3cm} p{3cm} p{5cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		\multirow{4}{3cm}{EquationStruct} & \multirow{4}{3cm}{$String^2$, 
		$equationStruct^2$} & \multirow{4}{3cm}{$equationStruct$} & 
		EQ\_INSUFF\_PARAMS,\\
		&  & & EQ\_WRONG\_VARNAME\_TYPE,\\
		&  & & EQ\_WRONG\_OPERATOR\_TYPE,\\
		& & & EQ\_WRONG\_OPERAND\_TYPE\\
		GetOperator & - & $String$ & - \\
		GetVariableName & - & $String$ & - \\
		GetLeftOperand & - & $equationStruct$ & -\\
		GetRightOperand & - & $equationStruct$ & - \\
		\multirow{2}{3cm}{SetLeftOperand} & \multirow{2}{3cm}{$equationStruct$} 
		& \multirow{2}{3cm}{-} & EQ\_INSUFF\_PARAMS,\\
		& & & EQ\_WRONG\_OPERAND\_TYPE\\
		\multirow{2}{3cm}{SetRightOperand} & 
		\multirow{2}{3cm}{$equationStruct$} & \multirow{2}{3cm}{-} & 
		EQ\_INSUFF\_PARAMS,\\
		& & & EQ\_WRONG\_OPERAND\_TYPE\\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\# To support \rref{R_conditionfx} and \rref{R_CalculateCompose}
\begin{itemize}
	\item $operator : String$
	\item $variableName : String$
	\item $leftOperand : equationStruct$
	\item $rightOperand : equationStruct$
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
	\item The decomposition of the user equation is handled by the Equation 
	Conversion module (Section~\ref{Module_equationconversion}).
	\item Unsupported operators are identified and handled in the Equation 
	Conversion module (Section~\ref{Module_equationconversion}).
	\item There is no setter method for the $operator$ field because it will 
	not be changed after initialization.
	\item The values for $leftOperand$ and $rightOperand$ can be set to 
	\texttt{NULL} as required.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent EquationStruct($op, vName, eStruct1, eStruct2$):
\begin{itemize}
	\item output: $out := equationStruct$
	\item transition: Update state variables $operator$, $variableName$, 
	$leftOperand$, and $rightOperand$ with the provided values $op$, $vName$, 
	$eStruct1,$ and $eStruct2$
	\item exception: $exc := \\
	(\nexists op \vee \nexists vName \vee \nexists eStruct1 \vee \nexists 
	eStruct2 \Rightarrow EQ\_INSUFF\_PARAMS)\\
	|\\
	(vName \neq string \Rightarrow EQ\_WRONG\_VARNAME\_TYPE) \\
	|\\
	(op \neq string \Rightarrow EQ\_WRONG\_OPERATOR\_TYPE) \\
	|\\
	(eStruct1 \neq equationStruct \vee eStruct1 \neq NULL \vee eStruct2 \neq 
	equationStruct \vee eStruct2 \neq NULL \Rightarrow EQ\_WRONG\_OPERAND\_TYPE)
	$
\end{itemize}

\noindent GetOperator():
\begin{itemize}
	\item output: $out := operator$
	\item exception: N/A
\end{itemize}

\noindent GetVariableName():
\begin{itemize}
	\item output: $out := variableName$
	\item exception: N/A
\end{itemize}

\noindent GetLeftOperand():
\begin{itemize}
	\item output: $out := leftOperand$
	\item exception: N/A
\end{itemize}

\noindent GetRightOperand():
\begin{itemize}
	\item output: $out := rightOperand$
	\item exception: N/A
\end{itemize}

\noindent SetLeftOperand($eStruct$):
\begin{itemize}
	\item transition: Update state variable $leftOperand$ with the provided 
	value $eStruct$
	\item exception: $exc := \\
	(\nexists eStruct \Rightarrow EQ\_INSUFF\_PARAMS)\\
	|\\
	(eStruct \neq equationStruct \Rightarrow EQ\_WRONG\_OPERAND\_TYPE)$	
\end{itemize}

\noindent SetRightOperand($eStruct$):
\begin{itemize}
	\item transition: Update state variable $rightOperand$ with the provided 
	value $eStruct$
	\item exception: $exc := \\
	(\nexists eStruct \Rightarrow EQ\_INSUFF\_PARAMS)\\
	|\\
	(eStruct \neq equationStruct \Rightarrow EQ\_WRONG\_OPERAND\_TYPE)$	
\end{itemize}

\newpage

\bibliographystyle {plainnat}
\bibliography {../../../ReferenceMaterial/References}

\newpage

\section{Appendix} \label{Appendix}

\renewcommand{\arraystretch}{1.2}

\begin{longtable}{l p{9.5cm}}
	\caption{Possible Error Exceptions} \\
	\toprule
	\textbf{Message ID} & \textbf{Error Message} \\
	\midrule
	EQ\_INSUFF\_PARAMS & Error: Insufficient number of parameters provided to 
	the	equation data structure.\\
	EQ\_WRONG\_OPERAND\_TYPE & Error: Operands must have type 
	$equationStruct$.\\
	EQC\_UNSUPPORTED\_OP & Error: The user equation contains an unsupported 
	operator. Supported operators include $<supportedOperators>$.\\
	EQC\_INCOMPLETE\_OP & Error: An operator was found that does not have 
	sufficient operands. \\
	IN\_BAD\_FILE & Error: The file could not be read. \\
	IN\_EMPTY\_FILE & Error: The file was empty. \\
	IVC\_CONV\_ERR\_MIN & Error: The string provided for the minimum bound 
	cannot be converted to a real number. \\
	IVC\_CONV\_ERR\_MAX & Error: The string provided for the maximum bound 
	cannot be converted to a real number.\\
	SOL\_INSUFF\_PARAMS & Error: Insufficient number of parameters provided to 
	the range solver.\\
	SOL\_WRONG\_EQ\_TYPE & Error: An equation must be provided to the solver 
	that has type $equationStruct$.\\
	SOL\_WRONG\_IV\_TYPE & Error: An list of intervals must be provided to the 
	range solver. If no intervals exist, the value must be identified as 
	\texttt{NULL}.\\
	SOL\_UNSUPPORTED\_OP & Error: An unsupported operation was encountered 
	while solving for the range of the equation.\\
	VC\_NO\_FUNC & Error: No user equation was received. \\
	\bottomrule
\end{longtable}

\begin{longtable}{l p{9.5cm}}
	\caption{Possible Warning Exceptions} \\
	\toprule
	\textbf{Message ID} & \textbf{Error Message} \\
	\midrule
	EQ\_WRONG\_OPERATOR\_TYPE & Warning: The operator must have type $string$. 
	String type conversion has been applied.\\
	EQ\_WRONG\_VARNAME\_TYPE & Warning: The variable name must have type 
	$string$. String type conversion has been applied. \\
	EQC\_CONST\_FUNC & Warning: The user equation is a constant value and the 
	range will only include this value.\\
	IV\_ORD\_VIOLATED & Warning: Value provided for intervals are not in 
	increasing order. The values have been exchanged to maintain the interval 
	ordering. \\
	IVC\_NO\_MIN & Warning: No minimum interval bound given. Setting it to the 
	same value as the maximum bound. \\
	IVC\_NO\_MAX & Warning: No maximum interval bound given. Setting it to the 
	same value as the minimum bound. \\
	\bottomrule
\end{longtable}

\end{document}