\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[usenames,dvipsnames,table]{xcolor}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}
\usepackage{listings}

\lstset{ %
	breaklines = true
}

\externaldocument{../../SRS/SRS}
\newcommand{\rref}[1]{R\ref{#1}}
\newcommand{\ddref}[1]{DD\ref{#1}}

\hypersetup{
	bookmarks=true,     % show bookmarks bar?
	colorlinks=true,       % false: boxed links; true: colored links
	citecolor=ForestGreen,
	filecolor=WildStrawberry,
	linkcolor=Purple,
	urlcolor=Cerulean      % color of external links
}

\usepackage{array}

\input{../../Comments}

\newcommand{\progname}{Companion Cube Calculator}
\newcommand{\prognameAbbrv}{$C^{3}$}

\begin{document}

\title{Module Interface Specification for the \progname{} (\prognameAbbrv{})}

\author{Geneva Smith}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
 & 1.0 & Initial draft completed\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See SRS Documentation at 
\url{https://github.com/GenevaS/CAS741/tree/master/Doc/SRS} for project 
symbols, abbreviations, and acronyms.

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for the 
\progname{} (\prognameAbbrv{}), a mathematical tool which determines the range 
of a user-specified function given the domains of the function's variables. The 
calculations are performed using interval arithmetic.

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at \url{https://github.com/GenevaS/CAS741}.

\section{Notation}

\wss{You should describe your notation.  You can use what is below as
  a starting point.}

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \progname. 

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
character & char & a single symbol or digit\\
integer & $\mathbb{Z}$ & a number without a fractional component in (-$\infty$, $\infty$) \\
natural number & $\mathbb{N}$ & a number without a fractional component in [1, 
$\infty$) \\
real & $\mathbb{R}$ & any number in (-$\infty$, $\infty$)\\
\bottomrule
\end{tabular} 
\end{center}

\noindent
The specification of \progname \ uses some derived data types: sequences, strings, and
tuples. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \progname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.

\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this 
project. It can be found at 
\url{https://github.com/GenevaS/CAS741/blob/master/Doc/Design/MG}.

\begin{table}[h!]
	\centering
	\begin{tabular}{p{0.35\textwidth} p{0.6\textwidth}}
		\toprule
		\textbf{Level 1} & \textbf{Level 2}\\
		\midrule
		
		{Hardware-Hiding Module} & - \\
		\midrule
		
		\multirow{7}{0.29\textwidth}{Behaviour-Hiding Module} & Control Flow 
		Module \\
		& User Input Module \\
		& Interval Conversion Module \\
		& Equation Conversion Module \\
		& Variable Consolidation Module \\
		& Range Solver Module \\
		& Output Module \\
		\midrule
		
		\multirow{2}{0.29\textwidth}{Software Decision Module} & Interval Data 
		Structure Module \\
		& Equation Data Structure Module \\
		\bottomrule
		
	\end{tabular}
	\caption{Module Hierarchy}
	\label{TblMH}
\end{table}

\newpage
~\newpage

\section{MIS of the Control Flow Module} 
\label{Module_controlflow}

\subsection{Module}

main

\subsection{Uses}

Input (Section~\ref{Module_userinput}), Consolidate 
(Section~\ref{Module_variableconsolidation}), Solver 
(Section~\ref{Module_rangesolver}), Output (Section~\ref{Module_output}), 
intervalStruct (Section~\ref{Module_intervaldatastructure}), equationStruct 
(Section~\ref{Module_equationdatastructure})


\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{3cm} p{3cm} p{3cm} p{5cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
main & - & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

N/A

\subsubsection{Access Routine Semantics}

\noindent main():
\begin{itemize}
\item transition: Create data structures to contain the user inputs and modify 
their states for the Output module.
\end{itemize}

\begin{lstlisting}
# Get User Input
  eqString := Input.getUserEquation()
  varList := Input.getVariableList()
 
# Convert input into equation and interval data structures using 
# the list of valid operators from Solver
  operators := Solver.getValidOperators()
  Consolidate.convertAndCheckInputs(eqString, varList, operators)
  
# Get the equation and interval data structures and pass them to 
# the Solver module
  equationData := Consolidate.getEquationStruct()
  intervalDataList := Consolidate.GetIntervalStructList()
  range := Solver.calculateRange(equationData, intervalDataList)
  
# Report the results back to the user
  Output.printInterval(range)
  Output.printEquationTree(equationData)
  for each interval in intervalDataList:
    Output.printInterval(interval)
\end{lstlisting}

\newpage

\section{MIS of the User Input Module} 
\label{Module_userinput}

\subsection{Module}

Input

\subsection{Uses}


\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3cm} p{4cm} p{4cm} p{2cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		\wss{accessProg} & - & - & - \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}


\subsubsection{Access Routine Semantics}

\noindent \wss{accessProg}():
\begin{itemize}
	\item transition: \wss{if appropriate} 
	\item output: \wss{if appropriate} 
	\item exception: \wss{if appropriate} 
\end{itemize}

\newpage

\section{MIS of the Interval Conversion Module} 
\label{Module_intervalconversion}

\subsection{Module}

\wss{Short name for the module}

\subsection{Uses}


\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3cm} p{4cm} p{4cm} p{2cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		\wss{accessProg} & - & - & - \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}


\subsubsection{Access Routine Semantics}

\noindent \wss{accessProg}():
\begin{itemize}
	\item transition: \wss{if appropriate} 
	\item output: \wss{if appropriate} 
	\item exception: \wss{if appropriate} 
\end{itemize}

\newpage

\section{MIS of the Equation Conversion Module} 
\label{Module_equationconversion}

\subsection{Module}

\wss{Short name for the module}

\subsection{Uses}


\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3cm} p{4cm} p{4cm} p{2cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		\wss{accessProg} & - & - & - \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}


\subsubsection{Access Routine Semantics}

\noindent \wss{accessProg}():
\begin{itemize}
	\item transition: \wss{if appropriate} 
	\item output: \wss{if appropriate} 
	\item exception: \wss{if appropriate} 
\end{itemize}

\newpage

\section{MIS of the Variable Consolidation Module} 
\label{Module_variableconsolidation}

\subsection{Module}

Consolidate

\subsection{Uses}


\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3cm} p{4cm} p{4cm} p{2cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		\wss{accessProg} & - & - & - \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}


\subsubsection{Access Routine Semantics}

\noindent \wss{accessProg}():
\begin{itemize}
	\item transition: \wss{if appropriate} 
	\item output: \wss{if appropriate} 
	\item exception: \wss{if appropriate} 
\end{itemize}

\newpage

\section{MIS of the Range Solver Module} 
\label{Module_rangesolver}

\subsection{Module}

Solver

\subsection{Uses}


\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3cm} p{4cm} p{4cm} p{2cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		\wss{accessProg} & - & - & - \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}


\subsubsection{Access Routine Semantics}

\noindent \wss{accessProg}():
\begin{itemize}
	\item transition: \wss{if appropriate} 
	\item output: \wss{if appropriate} 
	\item exception: \wss{if appropriate} 
\end{itemize}

\newpage

\section{MIS of the Output Module} 
\label{Module_output}

\subsection{Module}

Output

\subsection{Uses}

intervalStruct (Section~\ref{Module_intervaldatastructure}), equationStruct 
(Section~\ref{Module_equationdatastructure})

\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3cm} p{3cm} p{3cm} p{5cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		printInterval & $intervalStruct$ & - & - \\
		printEquationTree & $equationStruct$ & - & - \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

N/A

\subsubsection{Environment Variables}

\begin{itemize}
	\item cmd: the command-line interface
	\item win: a 2D sequence of pixels displayed on the screen
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
	\item There are no exceptions in this module because it is assumed that 
	only well-formed inputs will be passed in. This assumption is made knowing 
	that this module will only be called post-process and any errors in the 
	data structures have already been identified.
	\item The object passed to printEquationTree is the root of the equation 
	tree
\end{itemize}


\subsubsection{Access Routine Semantics}

\noindent printIntervalList($intervalStruct$):
\begin{itemize}
	\item transition: If the user interface is the command-line, write the 
	interval $intervalStruct$ to cmd. If the user interface is a GUI, modify 
	win so that the interval is displayed. In both cases, the variable name of 
	the interval must also be displayed.
	\item exception: N/A
\end{itemize}

\noindent printEquationTree($equationStruct$):
\begin{itemize}
	\item transition: If the user interface is the command-line, write the 
	equation tree to cmd. If the user interface is a GUI, modify win so that 
	the equation tree is displayed.
	\item exception: N/A
\end{itemize}

\newpage

\section{MIS of the Interval Data Structure Module} 
\label{Module_intervaldatastructure}

\subsection{Module}

intervalStruct

\subsection{Uses}

N/A

\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3cm} p{3cm} p{3cm} p{5cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		\multirow{3}{3cm}{intervalStruct} & \multirow{3}{3cm}{$\mathbb{R}^2$} & 
		\multirow{3}{4cm}{$intervalStruct$} & 
		IV\_NOT\_REAL\_TYPE, \\
		 &  &  & IV\_INSUFF\_PARAMS, \\
		  &  &  & ORD\_VIOLATED \\
		GetMinRange & - & $\mathbb{R}$ & - \\
		GetMaxRange & - & $\mathbb{R}$ & - \\
		\multirow{3}{3cm}{SetMinRange} & \multirow{3}{3cm}{$\mathbb{R}$} & 
		\multirow{3}{3cm}{-} & IV\_NOT\_REAL\_TYPE, \\
		 &  &  & IV\_INSUFF\_PARAMS, \\
		  &  &  & ORD\_VIOLATED \\
		\multirow{3}{3cm}{SetMaxRange} & \multirow{3}{3cm}{$\mathbb{R}$} & 
		\multirow{3}{3cm}{-} & IV\_NOT\_REAL\_TYPE, \\
		 &  &  & IV\_INSUFF\_PARAMS, \\
		   &  &  & ORD\_VIOLATED \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\# For \rref{R_conditionX} using \ddref{DD_interval}
\begin{itemize}
	\item $a$ : $\mathbb{R}$
	\item $b$ : $\mathbb{R}$
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent intervalStruct($val1, val2$):
\begin{itemize}
	\item output: $out := intervalStruct$
	\item transition: Update state variables $a$ and $b$ with the provided 
	values $val1$ and $val2$
	\item exception: $exc := \\
	(val1 \notin \mathbb{R} \vee val2 \notin \mathbb{R} \Rightarrow 
	IV\_NOT\_REAL\_TYPE) \\
	|\\
	(\nexists val1 \vee \nexists val2 \Rightarrow IV\_INSUFF\_PARAMS)\\
	|\\
	(val1 > val2 \Rightarrow ORD\_VIOLATED)$
\end{itemize}

\noindent intervalStruct.GetMinRange():
\begin{itemize}
	\item output: $out := a$
	\item exception: N/A
\end{itemize}

\noindent intervalStruct.GetMaxRange():
\begin{itemize}
	\item output: $out := b$
	\item exception: N/A
\end{itemize}

\noindent intervalStruct.SetMinRange($val$):
\begin{itemize}
	\item transition: Update state variable $a$ with the provided value $val$
	\item exception: $exc := \\
	(val \notin \mathbb{R} \Rightarrow IV\_NOT\_REAL\_TYPE) \\
	|\\
	(\nexists val \Rightarrow IV\_INSUFF\_PARAMS) \\
	|\\
	(val > b \Rightarrow ORD\_VIOLATED)$
\end{itemize}

\noindent intervalStruct.SetMaxRange($val$):
\begin{itemize}
	\item transition: Update state variable $b$ with the provided value $val$
	\item exception: $exc := \\
	(val \notin \mathbb{R} \Rightarrow IV\_NOT\_REAL\_TYPE) \\
	|\\
	(\nexists val \Rightarrow IV\_INSUFF\_PARAMS) \\
	|\\
	(val < a \Rightarrow ORD\_VIOLATED)$
\end{itemize}

\newpage

\section{MIS of the Equation Data Structure Module} 
\label{Module_equationdatastructure}

\subsection{Module}

equationStruct

\subsection{Uses}

N/A

\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3cm} p{3cm} p{3cm} p{5cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		\multirow{3}{3cm}{equationStruct} & \multirow{3}{3cm}{String, 
		$equationStruct^2$} & \multirow{3}{3cm}{$equationStruct$} & 
		EQ\_INSUFF\_PARAMS,\\
		&  & & EQ\_WRONG\_OPERATOR\_TYPE,\\
		& & & EQ\_WRONG\_OPERAND\_TYPE\\
		GetOperator & - & String & - \\
		GetLeftOperand & - & $equationStruct$ & -\\
		GetRightOperand & - & $equationStruct$ & - \\
		\multirow{2}{3cm}{SetLeftOperand} & \multirow{2}{3cm}{$equationStruct$} 
		& \multirow{2}{3cm}{-} & EQ\_INSUFF\_PARAMS,\\
		& & & EQ\_WRONG\_OPERAND\_TYPE\\
		\multirow{2}{3cm}{SetRightOperand} & 
		\multirow{2}{3cm}{$equationStruct$} & \multirow{2}{3cm}{-} & 
		EQ\_INSUFF\_PARAMS,\\
		& & & EQ\_WRONG\_OPERAND\_TYPE\\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\# To support \rref{R_conditionfx} and \rref{R_CalculateCompose}
\begin{itemize}
	\item $op$ : string
	\item $x$ : $equationStruct$
	\item $y$ : $equationStruct$
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
	\item The decomposition of the user equation is handled by the Equation 
	Conversion module (Section~\ref{Module_equationconversion}).
	\item Unsupported operators are identified and handled in the Equation 
	Conversion module (Section~\ref{Module_equationconversion}).
	\item There is no setter method for the $op$ field because it will not be 
	changed after initialization.
	\item The values for $x$ and $y$ can be set to \texttt{NULL} as required.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent equationStruct($operator, eStruct1, eStruct2$):
\begin{itemize}
	\item output: $out := equationStruct$
	\item transition: Update state variables $op$, $x$, and $y$ with the 
	provided values $operator$, $eStruct1,$ and $eStruct2$
	\item exception: $exc := \\
	(\nexists operator \vee \nexists eStruct1 \vee \nexists eStruct2 
	\Rightarrow EQ\_INSUFF\_PARAMS)\\
	|\\
	(operator \neq string \Rightarrow EQ\_WRONG\_OPERATOR\_TYPE) \\
	|\\
	(eStruct1 \neq equationStruct \vee eStruct2 \neq equationStruct 
	\\ \Rightarrow EQ\_WRONG\_OPERAND\_TYPE)
	$
\end{itemize}

\noindent equationStruct.GetOperator():
\begin{itemize}
	\item output: $out := op$
	\item exception: N/A
\end{itemize}

\noindent equationStruct.GetLeftOperand():
\begin{itemize}
	\item output: $out := x$
	\item exception: N/A
\end{itemize}

\noindent equationStruct.GetRightOperand():
\begin{itemize}
	\item output: $out := y$
	\item exception: N/A
\end{itemize}

\noindent SetLeftOperand($eStruct$):
\begin{itemize}
	\item transition: Update state variable $x$ with the provided value 
	$eStruct$
	\item exception: $exc := \\
	(\nexists eStruct \Rightarrow EQ\_INSUFF\_PARAMS)\\
	|\\
	(eStruct \neq equationStruct \Rightarrow EQ\_WRONG\_OPERAND\_TYPE)$	
\end{itemize}

\noindent SetRightOperand($eStruct$):
\begin{itemize}
	\item transition: Update state variable $y$ with the provided value 
	$eStruct$
	\item exception: $exc := \\
	(\nexists eStruct \Rightarrow EQ\_INSUFF\_PARAMS)\\
	|\\
	(eStruct \neq equationStruct \Rightarrow EQ\_WRONG\_OPERAND\_TYPE)$	
\end{itemize}

\newpage

\bibliographystyle {plainnat}
\bibliography {../../../ReferenceMaterial/References}

\newpage

\section{Appendix} \label{Appendix}

\renewcommand{\arraystretch}{1.2}

\begin{longtable}{l p{9.5cm}}
	\caption{Possible Exceptions} \\
	\toprule
	\textbf{Message ID} & \textbf{Error Message} \\
	\midrule
	EQ\_INSUFF\_PARAMS & Error: Insufficient number of parameters provided to 
	equation data structure.\\
	EQ\_WRONG\_OPERAND\_TYPE & Error: Operands must have type 
	$equationStruct$.\\
	EQ\_WRONG\_OPERATOR\_TYPE & Warning: The operator must have type $string$. 
	String type conversion has been applied.\\
	IV\_NOT\_REAL\_TYPE & Error: Interval values must be of type real. \\
	IV\_INSUFF\_PARAMS & Error: Insufficient number of parameters provided to 
	interval data structure. \\
	ORD\_VIOLATED & Warning: Value provided for intervals are not in increasing 
	order. The values have been exchanged to maintain the interval ordering. \\
	\bottomrule
\end{longtable}

\end{document}