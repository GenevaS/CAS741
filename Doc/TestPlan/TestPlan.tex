\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{txfonts}
\usepackage[nocenter]{qtree}

\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=ForestGreen,
    filecolor=WildStrawberry,
    linkcolor=Purple,
    urlcolor=Cerulean
}
\usepackage[round]{natbib}

\input{../Comments}

\newcommand{\progname}{Companion Cube Calculator} % PUT YOUR PROGRAM NAME HERE
\newcommand{\prognameAbbrv}{$C^{3}$}
\newcommand{\srsVersion}{1.0.2}

\begin{document}

\title{Test Plan for the \progname{} (\prognameAbbrv{}) Tool} 
\author{Geneva Smith}
\date{\today}
	
\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
 & 1.0 & Initial draft completed\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

\renewcommand{\arraystretch}{1.2}
\begin{tabular}{l l} 
  \toprule		
  \textbf{Symbol} & \textbf{Description}\\
  \midrule 
  \prognameAbbrv{} & \progname{}\\
  GUI & Graphical User Interface\\
  IDE & Integrated Development Environment\\
  SRS & Software Requirements Specification\\
  T & Test\\
  \bottomrule
\end{tabular}\\

\wss{symbols, abbreviations or acronyms -- you can reference the SRS tables if needed}

\newpage

\tableofcontents

%\listoftables

%\listoffigures

\newpage

\pagenumbering{arabic}

\section{General Information}
This document is a software test plan for the \progname{} (\prognameAbbrv{}), a 
mathematical tool which determines the range of a user-specified function given 
the domains of the function's variables. The calculations are performed using 
interval arithmetic.

\subsection{Purpose}
This document describes the software test plan for the \prognameAbbrv{} tool 
and is informed by its SRS documentation (version \srsVersion{}), including a 
description of automated testing approach, tools, and black box test cases. The 
purpose of documenting this information is to guide the product testing for the 
initial product release and to provide a basis for regression testing as 
further developments are made to the \prognameAbbrv{} tool.

This document is intended for readers who wish to test the initial version of 
the product, as well as those who want to refine and expand the tool. As 
changes are made to the \prognameAbbrv{} tool, these test cases will form the 
foundation of regression testing and will help ensure that any changes made to 
the product do not affect its original purpose or core functionality.

This test plan is intended to be used for version 1.0 of the \prognameAbbrv{} 
tool, and will only contain test information related to the product description 
in the product's SRS documentation (version \srsVersion{}). Any functionality 
defined beyond the scope of the SRS document are not included in this version 
of the test plan.

\subsection{Scope}
The \prognameAbbrv{} tool relies on interval arithmetic in the domain of real 
numbers ($\varmathbb{R}$), which means that many of its functions can be 
empirically tested. The tool has not yet been built, so the plan not include 
implementation-specific tests. Instead, this plan will outline black box tests 
that abstracts the tool into modules based on the requirements identified in 
the SRS documentation.

The purpose of this plan is to guide the modularization of the \prognameAbbrv{} 
tool design so that it is easy to test and maintain. It also forms the 
foundation of the kinds of behaviours that the tool should exhibit when it 
encounters malformed  user inputs and unexpected values during its calculations.

\subsection{Overview of Document}
This document presents a general description of the \prognameAbbrv{} tool to 
establish the context of the test plan and a list of team members responsible 
for executing it. This background information is followed by a high-level 
description of the test plan, including the automated testing approach, 
verification tools, and non-testing based verification methods that will be 
used. The general plan outline is followed by a description of the system test 
which is designed to determine if the requirements from the associated SRS 
document are satisfied. The final section describes how unit testing will be 
implemented when the internal workings of the \prognameAbbrv{} tool are 
established.

\section{Plan}
\label{testplan_highlevel}
This section describes the test plan for the \prognameAbbrv{} tool from a 
high-level perspective, outlining the methodologies and tools that will be used 
during the verification process, and the team responsible for executing the 
plan.
	
\subsection{Software Description}
The \prognameAbbrv{} tool is a stand-alone application for calculating 
the mathematical range of a user-defined function given the domains of the 
function's component variables. Function ranges and variable domains are 
represented by intervals, where intervals are defined as a sequence of 
continuous values bounded by a minimum and maximum value. The minimum and 
maximum values for any given interval must be defined. To perform its 
calculations, the \prognameAbbrv{} tool uses interval arithmetic.

The purpose of this product is to produce accurate results when they can be 
found. If a result cannot be found, the tool is expected to communicate the 
reason back to the user. Calculations must be accurate within an error range of 
the host machine's floating point error. These tasks must be completed while 
presenting all communications to the user in standard function and interval 
notation.

\subsection{Test Team}

The test team assigned to implement this plan is Geneva Smith.

\subsection{Automated Testing Approach}
The \prognameAbbrv{} tool will almost exclusively rely on automated test 
approaches for its verification process, with the notable exceptions of the 
non-functional requirements for correctness, verifiability, usability and 
maintainability described in the SRS document (version \srsVersion{}). The 
verification of correctness cannot be tested by a machine because it relies on 
mathematical proofs and the remaining non-functional requirements of 
verifiability, usability, and maintainability are intended for a 
human audience. These types of verifications are best handled by manual tests 
and user studies.

The functional requirements tests (Section \ref{testplan_functional}) focus on 
the behaviour that is expected at each stage of the \prognameAbbrv{} tools work 
flow. Since these behaviours are internal to the tool with no user guidance, 
these behaviours can be tested automatically using a series of black box unit 
tests. Some of the non-functional requirements such as reliability and 
robustness (Section \ref{testplan_nonfunctional}), can also be tested using 
automated approaches because they focus on floating-point error rates and data 
constraints.

Many of the unit tests are designed to be used as part of integration testing, 
and the system will be progressively tested starting from gathering user inputs 
and ending with the system's outputs. Outputs can be messages informing the 
user of erroneous behaviours or malformed inputs, and calculated result if a no 
errors are detected.

The remaining unit tests are designed to test the correctness of the tool's 
calculation. Some of the tests check simple, two variable equations to ensure 
that the individual calculation types are behaving correctly. The remaining 
tests will ensure that equations with multiple operators are being decomposed 
correctly by comparing it to expected results. Once a set of equations has been 
selected for this task, regression testing becomes available to check further 
developments to the \prognameAbbrv{} tool.

\subsection{Verification Tools}
The C\# programming language has been chosen for the development of the 
\prognameAbbrv{} tool because of its GUI building capabilities. The supporting 
IDE, Visual Studio 2017 (Enterprise Edition), comes with a number of built-in 
test tools, including:

\begin{itemize}
	\item A unit test framework and management system
	\item Automated GUI testing
	\item Code coverage tools that can be run ``live" as code is written
\end{itemize}

Depending on the complexity of the GUI, the GUI testing tool might not be used.

\subsection{Non-Testing Based Verification}

There are no non-testing based verification approaches in this test plan.

\section{System Test Description}
The system testing of the \prognameAbbrv{} tool will focus on inspecting and 
conditioning user inputs and ensuring that the \prognameAbbrv{} tool is able to 
produce descriptive outputs for both valid and invalid inputs. 

The goal of user input inspection and conditioning tests is to be sure that the 
\prognameAbbrv{} tool is able to identify and reject values that violate the 
assumptions. If the tool determines that the values do not violate the 
assumptions, it should be able to convert those values into the internal 
representations identified in the SRS document. For the purposes of this test 
plan, it is assumed that the user function $f(X)$ is represented internally as 
a parse tree.

Even if the user inputs are validated and conditioned correctly, it is still 
possible for the \prognameAbbrv{} tool to encounter invalid operations in an 
intermediary step while calculating a result. This makes it necessary to create 
a series of tests to determine how the tool will react to both supported and 
unsupported operations.
	
\subsection{Tests for Functional Requirements}
\label{testplan_functional}

\subsubsection{Getting User Inputs}
This test suite is designed to determine if the \ref{R_Inputs} functional 
requirement is satisfied.

\paragraph{User Inputs (As Expected)}

\begin{enumerate}
	
	\item{test-directinput}
	
	Type: Functional
	
	Initial State: New Session
	
	Input: $f(X) = x + y, x = [2,4], y = [2,4]$
	
	Output: Input received from direct input
	
	How test will be performed: Unit Test\\
	
	\item{test-fileinput}

	Type: Functional
	
	Initial State: New Session
	
	Input: File containing: $f(X) = x + y, x = [2,4], y = [2,4]$
	
	Output: Input received from file
	
	How test will be performed: Unit Test\\
	
	\item{test-badFileInput}
	
	Type: Functional
	
	Initial State: New Session
	
	Input: File that cannot be read
	
	Output: Error -- File cannot be read
	
	How test will be performed: Unit Test\\
\end{enumerate}
	
\paragraph{User Inputs (Function is a Constant Value)}

\begin{enumerate}	
	\item{test-input\_functionAsConstant}
	
	Type: Functional
	
	Initial State: New Session
	
	Input: $f(X) = 34$
	
	Output: N/A
	
	How test will be performed: Unit Test\\
\end{enumerate}
	
\paragraph{User Inputs (Extraneous Information)}
	
\begin{enumerate}
	\item{test-input\_variableNotInFunction}
	
	Type: Functional
	
	Initial State: New Session
	
	Input: $f(X) = 34$, $x = [2,4]$
	
	Output: Warning -- Function $f(X)$ does not contain name $x$ found in 
	variable list
	
	How test will be performed: Unit Test\\
	
\end{enumerate}
		
\paragraph{User Inputs (Missing Values)}

\begin{enumerate}

\item{test-input\_noFunction}

Type: Functional

Initial State: New Session

Input: $x = [2,4], y = [2,4]$

Output: Error -- Could not find function $f(X)$ with variables $x, y$

How test will be performed: Unit Test\\

\end{enumerate}

\paragraph{User Inputs (Incomplete Values)}

\begin{enumerate}
	
	\item{test-input\_missingFunctionValue}
	
	Type: Functional
	
	Initial State: New Session
	
	Input: $f(X) = x +$, $x = [2,4], y = [3,5]$
	
	Output: Error -- Function $f(X)$ is missing an operand for $+$
	
	How test will be performed: Unit Test\\
	
	\item{test-input\_missingMinDomainValue}
	
	Type: Functional
	
	Initial State: New Session
	
	Input: $f(X) = x + y$, $x = [,4], y = [3,5]$
	
	Output: Error -- Missing min domain value for $x$
	
	How test will be performed: Unit Test\\
	
	\item{test-input\_missingMaxDomainValue}
	
	Type: Functional
	
	Initial State: New Session
	
	Input: $\{f(X) = x + y, x = [2,4], y = [3,]\}$, $\{f(X) = x + y, x = 
	[2,4], y = [3]\}$
	
	Output: Error -- Missing max domain value for $y$
	
	How test will be performed: Unit Test
	
\end{enumerate}

\paragraph{User Inputs (Non-Numerical Value in Domains)}

\begin{enumerate}
	
	\item{test-input\_nonNumberInDomain}
	
	Type: Functional
	
	Initial State: New Session
	
	Input: $f(X) = x + y$, $x = [2,4], y = [a,5]$
	
	Output: Error -- Non-numerical value found in the domain for variable $y$
	
	How test will be performed: Unit Test\\
	
\end{enumerate}

\subsubsection{Conditioning User Inputs}
This test suite is designed to determine if the \ref{R_conditionX} and 
\ref{R_conditionfx} functional requirements are satisfied.

\paragraph{Parsing User Inputs (Single Operators)}

\begin{enumerate}
	
	\item{test-parse\_addition}
	
	Type: Functional
	
	Initial State: New Session
	
	Input: $f(X) = x + y$, $x = [2,4], y = [3,5]$
	
	Output: \Tree[.$+$ [.$x$ $[2,4]$ ] [.$y$ $[3,5]$ ] ]
	
	How test will be performed: Unit Testing\\
	
	\item{test-parse\_subtraction}
	
	Type: Functional
	
	Initial State: New Session
	
	Input: $f(X) = x - y$, $x = [2,4], y = [3,5]$
	
	Output: \Tree[.$-$ [.$x$ $[2,4]$ ] [.$y$ $[3,5]$ ] ]
	
	How test will be performed: Unit Testing\\
	
	\item{test-parse\_multiplication}
	
	Type: Functional
	
	Initial State: New Session
	
	Input: $f(X) = x \times y$, $x = [2,4], y = [3,5]$
	
	Output: \Tree[.$\times$ [.$x$ $[2,4]$ ] [.$y$ $[3,5]$ ] ]
	
	How test will be performed: Unit Testing\\
	
	\item{test-parse\_division}
	
	Type: Functional
	
	Initial State: New Session
	
	Input: $f(X) = x \div y$, $x = [2,4], y = [3,5]$
	
	Output: \Tree[.$\div$ [.$x$ $[2,4]$ ] [.$y$ $[3,5]$ ] ]
	
	How test will be performed: Unit Testing\\
	
	\item{test-parse\_divisionMixedIntervalQuotient}
	
	Type: Functional
	
	Initial State: New Session
	
	Input: $f(X) = x \div y$, $x = [-2,4], y = [3,5]$
	
	Output: \Tree[.$\div$ [.$x$ $[-2,4]$ ] [.$y$ $[3,5]$ ] ]
	
	How test will be performed: Unit Testing\\
	
	\item{test-parse\_divisionMixedIntervalDivisor}
	
	Type: Functional
	
	Initial State: New Session
	
	Input: $f(X) = x \div y$, $x = [2,4], y = [-3,5]$
	
	Output: Error -- Cannot perform division with a mixed interval divisor
	
	How test will be performed: Unit Testing\\
	
	\item{test-parse\_intervalAsExponents}
	
	Type: Functional
	
	Initial State: New Session
	
	Input: $f(X) = 2^x$, $x = [2,4]$
	
	Output: \Tree[.\^{} [.$2$ ] [.$x$ $[2,4]$ ] ]
	
	How test will be performed: Unit Testing\\
	
	\item{test-parse\_intervalWithExponent}
	
	Type: Functional
	
	Initial State: New Session
	
	Input: $f(X) = x^2$, $x = [2,4]$
	
	Output: \Tree[.\^{} [.$x$ $[2,4]$ ] [.$2$ ]  ]
	
	How test will be performed: Unit Testing\\
	
	\item{test-parse\_intervalsOnlyExponentiation}
	
	Type: Functional
	
	Initial State: New Session
	
	Input: $f(X) = x^y$, $x = [2,4], y = [3,5]$
	
	Output: Error -- Cannot perform exponentiation when the base number and the 
	exponent are intervals
	
	How test will be performed: Unit Testing\\
	
	\item{test-parse\_multipleOperatorsInFX}
	
	Type: Static
	
	Initial State: New Session
	
	Input: $R(f(X)) = R(f_1(X)) <op> R(f_2(X))$, where $R(f_1(X)), R(f_2(X))$ 
	exist
	
	Output: True
	
	How test will be performed: Induction\\
	
	\item{test-parse\_multipleOperatorsInFX}
	
	Type: Static
	
	Initial State: New Session
	
	Input: $R(f(X)) = R(f_1(X)) <op> R(f_2(X))$, where $R(f_1(X))$ or 
	$R(f_2(X))$ do not exist
	
	Output: Error -- Calculation path encountered an unsupported interval 
	operation
	
	How test will be performed: Induction\\
	
\end{enumerate}

\subsubsection{Verifying Data Constraints}
This test suite is designed to determine if the \ref{R_verifyinputs} functional 
requirement is satisfied.

\paragraph{Domain Constraints}

\begin{enumerate}
	
	\item{test-input\_noDomain}
	
	Type: Functional
	
	Initial State: New Session
	
	Input: $f(X) = x + y$, $x = [2,4]$
	
	Output: Error -- No domain for variable $y$
	
	How test will be performed: Unit Test\\
\end{enumerate}

\paragraph{Exponentiation Constraints}

\begin{enumerate}	
	\item{test-parse\_intervalAsExponentsInvalidBase}
	
	Type: Functional
	
	Initial State: New Session
	
	Input: $f(X) = 1^x$, $x = [2,4]$
	
	Output: Error -- Cannot perform operation with an interval exponent when 
	the base number ($b$) $\leq 1$
	
	How test will be performed: Unit Testing\\
	
	\item{test-parse\_intervalWithInvalidExponent1}
	
	Type: Functional
	
	Initial State: New Session
	
	Input: $f(X) = x^{2.1}$, $x = [2,4]$
	
	Output: Warning -- Cannot perform operation with an exponent that is not a 
	whole number; the exponent has been rounded to 2\\
	\Tree[.\^{} [.$x$ $[2,4]$ ] [.$2$ ]  ]
	
	How test will be performed: Unit Testing\\
	
	\item{test-parse\_intervalWithInvalidExponent2}
	
	Type: Functional
	
	Initial State: New Session
	
	Input: $f(X) = x^{-1}$, $x = [2,4]$
	
	Output: Error -- Cannot perform operation exponentiation with an exponent 
	$< 0$
	
	How test will be performed: Unit Testing\\
	
\end{enumerate}

\subsection{Tests for Non-Functional Requirements}
\label{testplan_nonfunctional}

\subsubsection{Area of Testing1}
		
\paragraph{Title for Test}

\begin{enumerate}

\item{test-id1\\}

Type: 
					
Initial State: 
					
Input/Condition: 
					
Output/Result: 
					
How test will be performed: 
					
\item{test-id2\\}

Type: Functional, Dynamic, Manual, Static etc.
					
Initial State: 
					
Input: 
					
Output: 
					
How test will be performed: 

\end{enumerate}

\subsubsection{Area of Testing2}

...

\subsection{Traceability Between Test Cases and Requirements}

% \section{Tests for Proof of Concept}

% \subsection{Area of Testing1}
		
% \paragraph{Title for Test}

% \begin{enumerate}

% \item{test-id1\\}

% Type: Functional, Dynamic, Manual, Static etc.
					
% Initial State: 
					
% Input: 
					
% Output: 
					
% How test will be performed: 
					
% \item{test-id2\\}

% Type: Functional, Dynamic, Manual, Static etc.
					
% Initial State: 
					
% Input: 
					
% Output: 
					
% How test will be performed: 

% \end{enumerate}

% \subsection{Area of Testing2}

% ...
				
\section{Unit Testing Plan}
		
\wss{Unit testing plans for internal functions and, if appropriate, output
  files}

\bibliographystyle{plainnat}

\bibliography{SRS}

\newpage

\section{Appendix}

This is where you can place additional information.

\subsection{Symbolic Parameters}

The definition of the test cases will call for SYMBOLIC\_CONSTANTS.
Their values are defined in this section for easy maintenance.

\subsection{Usability Survey Questions?}

This is a section that would be appropriate for some teams.

\end{document}