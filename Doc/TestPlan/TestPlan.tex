\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{txfonts}
\usepackage[nocenter]{qtree}
\usepackage{xr}
\externaldocument{../SRS/SRS}
\newcommand{\rref}[1]{R\ref{#1}}
\newcommand{\ddref}[1]{DD\ref{#1}}

\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=ForestGreen,
    filecolor=WildStrawberry,
    linkcolor=Purple,
    urlcolor=Cerulean
}
\usepackage[round]{natbib}

\input{../Comments}

\newcommand{\progname}{Companion Cube Calculator} % PUT YOUR PROGRAM NAME HERE
\newcommand{\prognameAbbrv}{$C^{3}$}
\newcommand{\srsVersion}{1.0.2}

\begin{document}

\title{Test Plan for the \progname{} (\prognameAbbrv{}) Tool} 
\author{Geneva Smith}
\date{\today}
	
\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
 & 1.0 & Initial draft completed\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

\renewcommand{\arraystretch}{1.2}
\begin{tabular}{l l} 
  \toprule		
  \textbf{Symbol} & \textbf{Description}\\
  \midrule 
  \prognameAbbrv{} & \progname{}\\
  GUI & Graphical User Interface\\
  IDE & Integrated Development Environment\\
  SRS & Software Requirements Specification\\
  T & Test\\
  \bottomrule
\end{tabular}\\

\wss{symbols, abbreviations or acronyms -- you can reference the SRS tables if needed}

\newpage

\tableofcontents

%\listoftables

%\listoffigures

\newpage

\pagenumbering{arabic}

\section{General Information}
This document is a software test plan for the \progname{} (\prognameAbbrv{}), a 
mathematical tool which determines the range of a user-specified function given 
the domains of the function's variables. The calculations are performed using 
interval arithmetic.

\subsection{Purpose}
This document describes the software test plan for the \prognameAbbrv{} tool 
and is informed by its SRS documentation (version \srsVersion{}), including a 
description of automated testing approach, tools, and black box test cases. The 
purpose of documenting this information is to guide the product testing for the 
initial product release and to provide a basis for regression testing as 
further developments are made to the \prognameAbbrv{} tool.

This document is intended for readers who wish to test the initial version of 
the product, as well as those who want to refine and expand the tool. As 
changes are made to the \prognameAbbrv{} tool, these test cases will form the 
foundation of regression testing and will help ensure that any changes made to 
the product do not affect its original purpose or core functionality.

This test plan is intended to be used for version 1.0 of the \prognameAbbrv{} 
tool, and will only contain test information related to the product description 
in the product's SRS documentation (version \srsVersion{}). Any functionality 
defined beyond the scope of the SRS document are not included in this version 
of the test plan.

\subsection{Scope}
The \prognameAbbrv{} tool relies on interval arithmetic in the domain of real 
numbers ($\varmathbb{R}$), which means that many of its functions can be 
empirically tested. The tool has not yet been built, so the plan not include 
implementation-specific tests. Instead, this plan will outline black box tests 
that abstracts the tool into modules based on the requirements identified in 
the SRS documentation.

The purpose of this plan is to guide the modularization of the \prognameAbbrv{} 
tool design so that it is easy to test and maintain. It also forms the 
foundation of the kinds of behaviours that the tool should exhibit when it 
encounters malformed  user inputs and unexpected values during its calculations.

\subsection{Overview of Document}
This document presents a general description of the \prognameAbbrv{} tool to 
establish the context of the test plan and a list of team members responsible 
for executing it. This background information is followed by a high-level 
description of the test plan, including the automated testing approach, 
verification tools, and non-testing based verification methods that will be 
used. The general plan outline is followed by a description of the system test 
which is designed to determine if the requirements from the associated SRS 
document are satisfied. The final section describes how unit testing will be 
implemented when the internal workings of the \prognameAbbrv{} tool are 
established.

\section{Plan}
\label{testplan_highlevel}
This section describes the test plan for the \prognameAbbrv{} tool from a 
high-level perspective, outlining the methodologies and tools that will be used 
during the verification process, and the team responsible for executing the 
plan.
	
\subsection{Software Description}
The \prognameAbbrv{} tool is a stand-alone application for calculating 
the mathematical range of a user-defined function given the domains of the 
function's component variables. Function ranges and variable domains are 
represented by intervals, where intervals are defined as a sequence of 
continuous values bounded by a minimum and maximum value. The minimum and 
maximum values for any given interval must be defined. To perform its 
calculations, the \prognameAbbrv{} tool uses interval arithmetic.

The purpose of this product is to produce accurate results when they can be 
found. If a result cannot be found, the tool is expected to communicate the 
reason back to the user. Calculations must be accurate within an error range of 
the host machine's floating point error. These tasks must be completed while 
presenting all communications to the user in standard function and interval 
notation.

\subsection{Test Team}

The test team assigned to implement this plan is Geneva Smith.

\subsection{Automated Testing Approach}
The \prognameAbbrv{} tool will almost exclusively rely on automated test 
approaches for its verification process, with the notable exceptions of the 
non-functional requirements for correctness, verifiability, usability and 
maintainability described in the SRS document (version \srsVersion{}). The 
verification of correctness cannot be tested by a machine because it relies on 
mathematical proofs and the remaining non-functional requirements of 
verifiability, usability, and maintainability are intended for a 
human audience. These types of verifications are best handled by manual tests 
and user studies.

The functional requirements tests (Section \ref{testplan_functional}) focus on 
the behaviour that is expected at each stage of the \prognameAbbrv{} tools work 
flow. Since these behaviours are internal to the tool with no user guidance, 
these behaviours can be tested automatically using a series of black box unit 
tests. Some of the non-functional requirements such as reliability and 
robustness (Section \ref{testplan_nonfunctional}), can also be tested using 
automated approaches because they focus on floating-point error rates and data 
constraints.

Many of the unit tests are designed to be used as part of integration testing, 
and the system will be progressively tested starting from gathering user inputs 
and ending with the system's outputs. Outputs can be messages informing the 
user of erroneous behaviours or malformed inputs, and calculated result if a no 
errors are detected.

The remaining unit tests are designed to test the correctness of the tool's 
calculation. Some of the tests check simple, two variable equations to ensure 
that the individual calculation types are behaving correctly. The remaining 
tests will ensure that equations with multiple operators are being decomposed 
correctly by comparing it to expected results. Once a set of equations has been 
selected for this task, regression testing becomes available to check further 
developments to the \prognameAbbrv{} tool.

\subsection{Verification Tools}
The C\# programming language has been chosen for the development of the 
\prognameAbbrv{} tool because of its GUI building capabilities. The supporting 
IDE, Visual Studio 2017 (Enterprise Edition), comes with a number of built-in 
test tools, including:

\begin{itemize}
	\item \textbf{A unit test framework and management system}\\
	This forms the bulk of the automated testing approach and will be used for 
	unit, integration, system, and regression testing.
	\item \textbf{Automated GUI testing}\\
	This version of Visual Studio allows developers to record a series of 
	interactions with a GUI that can be played multiple times for testing. This 
	can help save time by making traditionally manual test cases into automated 
	ones. Depending on the complexity of the GUI, this tool might not be used.
	\item \textbf{Code coverage tools that can be run ``live" as code is 
	written}\\
	The code coverage tools in Visual Studio is connected to the test 
	management system and can help identify code that is not being run by any 
	unit test. The IDE can be configured so that this code coverage check is 
	run automatically while the program is being written.
\end{itemize}

\subsection{Non-Testing Based Verification}

There are no non-testing based verification approaches in this test plan due to 
time and team constraints.

\section{System Test Description}
The system testing of the \prognameAbbrv{} tool will focus on inspecting and 
conditioning user inputs and ensuring that the \prognameAbbrv{} tool is able to 
produce descriptive outputs for both valid and invalid inputs. 

The goal of user input inspection and conditioning tests is to be sure that the 
\prognameAbbrv{} tool is able to identify and reject values that violate the 
assumptions. If the tool determines that the values do not violate the 
assumptions, it should be able to convert those values into the internal 
representations identified in the SRS document. For the purposes of this test 
plan, it is assumed that the user function is represented internally as 
a parse tree.

Even if the user inputs are validated and conditioned correctly, it is still 
possible for the \prognameAbbrv{} tool to encounter invalid operations in an 
intermediary step while calculating a result. This makes it necessary to create 
a series of tests to determine how the tool will react to both supported and 
unsupported operations.

This test plan is meant to be executed in stages. The first stage is a 
white-box unit test of the functionality required to get raw inputs from the 
user. The subsequent stages are both integration and unit tests, where the test 
checks that the behaviour produced by the new modules is both working as 
expected and can communicate with the modules above it. The final tests in this 
chain, which show the calculations of the \prognameAbbrv{} tool, form the basis 
of regression testing and contains mathematical functions that will be 
incorrectly processed if the tool does not parse them correctly.
	
\subsection{Tests for Functional Requirements}
\label{testplan_functional}

\subsubsection{Getting User Inputs}
\label{tests_gettingInputs}
This test suite is designed to determine if the \rref{R_Inputs} (Accepting 
$f(V)$ and $D(v), v \in V$ as direct input or read from a file) functional 
requirement is satisfied and its associated data constraints from 
\rref{R_verifyinputs}.

The initial test cases (User Inputs (As Expected)) are the white-box unit tests 
that start the integration testing. The tests that follow these assume that 
these tests have passed.

\paragraph{User Inputs (As Expected)}

\begin{enumerate}
	
	\item{test-directinput}
	
	Type: Functional, Automatic, Unit
	
	Initial State: New Session
	
	Input: $f(V) = x + y, x = [2,4], y = [3,5]$
	
	Output: Input received from direct input
	
	How test will be performed: Unit Test\\
	
	\item{test-fileinput}

	Type: Functional, Automatic, Unit
	
	Initial State: New Session
	
	Input: File containing: $f(V) = x + y, x = [2,4], y = [3,5]$
	
	Output: Input received from file
	
	How test will be performed: Unit Test\\
\end{enumerate}
	
\paragraph{User Inputs (Bad File I/O)}

\begin{enumerate}
	
	\item{test-badFileInput}
	
	Type: Functional, Automatic, Unit
	
	Initial State: New Session
	
	Input: File that cannot be read
	
	Output: Error -- File cannot be read
	
	How test will be performed: Unit Test\\
\end{enumerate}
	
\paragraph{User Inputs (Function is a Constant Value)}

\begin{enumerate}	
	\item{test-input\_functionAsConstant}
	
	Type: Functional, Automatic, Integration
	
	Initial State: New Session
	
	Input: $f(V) = 34$
	
	Output: Warning -- Function $f(V)$ does not contain any variables
	
	How test will be performed: Unit Test\\
\end{enumerate}
	
\paragraph{User Inputs (Extraneous Information)}
	
\begin{enumerate}
	\item{test-input\_variableNotInFunction}
	
	Type: Functional, Automatic, Integration
	
	Initial State: New Session
	
	Input: $f(V) = x + y, x = [2,4], y = [3,5], z = [6,7]$
	
	Output: Warning -- Function $f(V)$ does not contain name $z$ found in 
	variable list
	
	How test will be performed: Unit Test\\
	
\end{enumerate}
		
\paragraph{User Inputs (Missing Values)}

\begin{enumerate}

	\item{test-input\_noFunction}
	
	Type: Functional, Automatic, Integration
	
	Initial State: New Session
	
	Input: $x = [2,4], y = [3,5]$
	
	Output: Error -- Could not find function $f(V)$ with variables $x, y$
	
	How test will be performed: Unit Test\\
	
	\item{test-input\_noDomain}
		
	Type: Functional
		
	Initial State: New Session
		
	Input: $f(X) = x + y$, $x = [2,4]$
		
	Output: Error -- No domain for variable $y$
		
	How test will be performed: Unit Test\\

\end{enumerate}

\paragraph{User Inputs (Incomplete Values)}

\begin{enumerate}
	
	\item{test-input\_missingFunctionValue1}
	
	Type: Functional, Automatic, Integration
	
	Initial State: New Session
	
	Input: $f(V) = x +$, $x = [2,4], y = [3,5]$
	
	Output: Error -- Function $f(V)$ is missing an operand for $+$
	
	How test will be performed: Unit Test\\
	
	\item{test-input\_missingFunctionValue2}
	
	Type: Functional, Automatic, Integration
	
	Initial State: New Session
	
	Input: $f(V) = x + * y$, $x = [2,4], y = [3,5]$
	
	Output: Error -- Function $f(V)$ is missing an operand between $+$ and $*$
	
	How test will be performed: Unit Test\\
	
	\item{test-input\_missingMinDomainValue}
	
	Type: Functional, Automatic, Integration
	
	Initial State: New Session
	
	Input: $f(V) = x + y$, $x = [,4], y = [3,5]$
	
	Output: Error -- Missing min domain value for $x$
	
	How test will be performed: Unit Test\\
	
	\item{test-input\_missingMaxDomainValue}
	
	Type: Functional, Automatic, Integration
	
	Initial State: New Session
	
	Input: $\{f(V) = x + y, x = [2,4], y = [3,]\}$, $\{f(V) = x + y, x = 
	[2,4], y = [3]\}$
	
	Output: Error -- Missing max domain value for $y$
	
	How test will be performed: Unit Test
	
\end{enumerate}

\paragraph{User Inputs (Non-Numerical Value in Domains)}

\begin{enumerate}
	
	\item{test-input\_nonNumberInDomain}
	
	Type: Functional, Automatic, Integration
	
	Initial State: New Session
	
	Input: $f(V) = x + y$, $x = [2,4], y = [a,5]$
	
	Output: Error -- Non-numerical value found in the domain for variable $y$
	
	How test will be performed: Unit Test\\
	
\end{enumerate}

\subsubsection{Conditioning User Inputs}
\label{tests_conditioningInputs}
This test suite is designed to determine if the \rref{R_conditionX} (Converting 
each $D(v)$ into \ddref{DD_interval}) and \rref{R_conditionfx} (Decomposing 
$f(V)$ into two-operand equations following BEDMAS rules) functional 
requirements and the associated data constraints from \rref{R_verifyinputs} are 
satisfied.

The tests that follow these assume that the user input tests 
(\ref{tests_gettingInputs}) have passed.

\paragraph{Addition, Subtraction, and Multiplication}

\begin{enumerate}
	
	\item{test-parse\_addition}
	
	Type: Functional, Automatic, Integration
	
	Initial State: New Session
	
	Input: $f(V) = x + y$, $x = [2,4], y = [3,5]$
	
	Output: \Tree[.$+$ [.$x$ $[2,4]$ ] [.$y$ $[3,5]$ ] ]
	
	How test will be performed: Unit Testing\\
	
	\item{test-parse\_subtraction}
	
	Type: Functional, Automatic, Integration
	
	Initial State: New Session
	
	Input: $f(V) = x - y$, $x = [2,4], y = [3,5]$
	
	Output: \Tree[.$-$ [.$x$ $[2,4]$ ] [.$y$ $[3,5]$ ] ]
	
	How test will be performed: Unit Testing\\
	
	\item{test-parse\_multiplication}
	
	Type: Functional, Automatic, Integration
	
	Initial State: New Session
	
	Input: $f(V) = x * y$, $x = [2,4], y = [3,5]$
	
	Output: \Tree[.$*$ [.$x$ $[2,4]$ ] [.$y$ $[3,5]$ ] ]
	
	How test will be performed: Unit Testing\\
	
\end{enumerate}

\paragraph{Division}

\begin{enumerate}
	
	\item{test-parse\_divisionPositiveDivisor}
	
	Type: Functional, Automatic, Integration
	
	Initial State: New Session
	
	Input: $f(V) = x / y$, $x = [2,4], y = [3,5]$
	
	Output: \Tree[.$/$ [.$x$ $[2,4]$ ] [.$y$ $[3,5]$ ] ]
	
	How test will be performed: Unit Testing\\
	
	\item{test-parse\_divisionNegativeDivisor}

	Type: Functional, Automatic, Integration

	Initial State: New Session

	Input: $f(V) = x / y$, $x = [2,4], y = [-3,-5]$

	Output: \Tree[.$/$ [.$x$ $[2,4]$ ] [.$y$ $[-3,-5]$ ] ]

	How test will be performed: Unit Testing\\
	
	\item{test-parse\_divisionMixedIntervalDivisor}

	Type: Functional, Automatic, Integration

	Initial State: New Session

	Input: $f(V) = x / y$, $x = [2,4], y = [-3,5]$

	Output: Error -- Cannot perform division with a mixed interval divisor

	How test will be performed: Unit Testing\\

	\item{test-parse\_divisionMixedIntervalQuotient}
	
	Type: Functional, Automatic, Integration
	
	Initial State: New Session
	
	Input: $f(V) = x / y$, $x = [-2,4], y = [3,5]$
	
	Output: \Tree[.$/$ [.$x$ $[-2,4]$ ] [.$y$ $[3,5]$ ] ]
	
	How test will be performed: Unit Testing\\
	
\end{enumerate}

\paragraph{Intervals as Exponents}

\begin{enumerate}
	
	\item{test-parse\_intervalAsExponents}
	
	Type: Functional, Automatic, Integration
	
	Initial State: New Session
	
	Input: $f(V) = 2^x$, $x = [2,4]$
	
	Output: \Tree[.$B^x$ [.$2$ ] [.$x$ $[2,4]$ ] ]
	
	How test will be performed: Unit Testing\\
	
	\item{test-parse\_intervalAsExponentsInvalidBase}
	
	Type: Functional, Automatic, Integration
	
	Initial State: New Session
	
	Input: $f(V) = 1^x$, $x = [2,4]$
	
	Output: Error -- Cannot perform operation with an interval exponent when 
	the base number ($B$) $\leq 1$
	
	How test will be performed: Unit Testing\\
	
\end{enumerate}

\paragraph{Intervals as Base Numbers}

\begin{enumerate}
	
	\item{test-parse\_intervalWithExponent}
	
	Type: Functional, Automatic, Integration
	
	Initial State: New Session
	
	Input: $f(V) = x^2$, $x = [2,4]$
	
	Output: \Tree[.$x^N$ [.$x$ $[2,4]$ ] [.$2$ ]  ]
	
	How test will be performed: Unit Testing\\
	
	\item{test-parse\_intervalWithInvalidExponent1}
	
	Type: Functional, Automatic, Integration
	
	Initial State: New Session
	
	Input: $f(V) = x^{2.1}$, $x = [2,4]$
	
	Output: Warning -- Cannot perform operation with an exponent that is not a 
	whole number; the exponent has been rounded to 2\\
	\Tree[.$x^N$ [.$x$ $[2,4]$ ] [.$2$ ]  ]
	
	How test will be performed: Unit Testing\\
	
	\item{test-parse\_intervalWithInvalidExponent2}
	
	Type: Functional, Automatic, Integration
	
	Initial State: New Session
	
	Input: $f(V) = x^{-1}$, $x = [2,4]$
	
	Output: Error -- Cannot perform operation exponentiation with an exponent 
	($N$) $< 0$
	
	How test will be performed: Unit Testing\\
	
\end{enumerate}

\paragraph{Intervals-Only Exponentiation}

\begin{enumerate}
	
	\item{test-parse\_intervalsOnlyExponentiation}
	
	Type: Functional, Automatic, Integration
	
	Initial State: New Session
	
	Input: $f(V) = x^y$, $x = [2,4], y = [3,5]$
	
	Output: Error -- Cannot perform exponentiation when the base number ($B$) 
	and the exponent ($N$) are intervals
	
	How test will be performed: Unit Testing\\
	
\end{enumerate}

\subsubsection{Composing Operators}
\label{tests_operatorComposition}
This test suite is designed to determine if the \rref{R_Calculate} (Solving 
each two-operand equation and composing the results) and \rref{R_VerifyOutput} 
(Ensuring that the calculated result is represented in closed, interval form) 
functional requirements, and the associated data constraints from 
\rref{R_VerifyOutputConstraints} are satisfied.

The tests that follow these assume that the user input tests 
(\ref{tests_gettingInputs}) and input conditioning tests 
(\ref{tests_conditioningInputs}) have passed.

\paragraph{Correctness of Operator Composition}

\begin{enumerate}
	
	\item{test-parse\_multipleOperatorsInFX}
	
	Type: Static, Manual, Unit
	
	Initial State: New Session
	
	Input: $R(f(V)) = R(f_1(V)) <op> R(f_2(V))$, where $R(f_1(V)), R(f_2(V))$ 
	exist
	
	Output: True
	
	How test will be performed: Induction\\
	
	\item{test-parse\_multipleOperatorsInFX}
	
	Type: Static, Manual, Unit
	
	Initial State: New Session
	
	Input: $R(f(V)) = R(f_1(V)) <op> R(f_2(V))$, where $R(f_1(V))$ or 
	$R(f_2(V))$ do not exist
	
	Output: Error -- Calculation path encountered an unsupported interval 
	operation
	
	How test will be performed: Induction\\
	
\end{enumerate}

\subsubsection{Presentation of Calculations to the User}
\label{tests_outputResults}
This test suite is designed to test that the final functional requirement, 
\rref{R_Output} (Showing the results to the user or an error if a result cannot 
be found) is satisfied. It is assumed that any inputs that do not produce a 
viable result have been caught previously and an appropriate error or warning 
message was presented to the user.

The tests that follow these assume that the user input tests 
(\ref{tests_gettingInputs}), input conditioning tests 
(\ref{tests_conditioningInputs}), and operator composition tests 
(\ref{tests_operatorComposition}) have passed.

\paragraph{Showing the Results to the User}

\begin{enumerate}
	
	\item{test-parse\_outputTest}
	
	Type: Functional, Automatic, Integration
	
	Initial State: New Session
	
	Input: $f(V) = x + y, x = [2,4], y = [3,5]$
	
	Output: $[5,9]$
	
	How test will be performed: Unit Testing\\
	
\end{enumerate}

\paragraph{Regression Tests}

\begin{enumerate}
	
	\item{test-parse\_simpleEquationWithDecimals}
	
	Type: Functional, Automatic, System, Regression
	
	Initial State: New Session
	
	Input: $f(V) = x + y, x = [2.5,4.33], y = [3.45,5.555]$
	
	Output: $[5.950,9.885]$
	
	How test will be performed: Unit Testing\\
	
	\item{test-parse\_precedenceOfOperators1}
	
	Type: Functional, Automatic, System, Regression
	
	Initial State: New Session
	
	Input: $f(V) = x + y * z, x = [2,4], y = [3,5], z = [2,2]$
	
	Output: $[8,14]$
	
	How test will be performed: Unit Testing\\
	
	\item{test-parse\_precedenceOfOperators2}
	
	Type: Functional, Automatic, System, Regression
	
	Initial State: New Session
	
	Input: $f(V) = (x + y) * z, x = [2,4], y = [3,5], z = [2,2]$
	
	Output: $[10,18]$
	
	How test will be performed: Unit Testing\\
	
\end{enumerate}

\subsection{Tests for Non-Functional Requirements}
\label{testplan_nonfunctional}

\subsubsection{Area of Testing1}
		
\paragraph{Title for Test}

\begin{enumerate}

\item{test-id1\\}

Type: 
					
Initial State: 
					
Input/Condition: 
					
Output/Result: 
					
How test will be performed: 
					
\item{test-id2\\}

Type: Functional, Dynamic, Manual, Static etc.
					
Initial State: 
					
Input: 
					
Output: 
					
How test will be performed: 

\end{enumerate}

\subsubsection{Area of Testing2}

...

\subsection{Traceability Between Test Cases and Requirements}

% \section{Tests for Proof of Concept}

% \subsection{Area of Testing1}
		
% \paragraph{Title for Test}

% \begin{enumerate}

% \item{test-id1\\}

% Type: Functional, Dynamic, Manual, Static etc.
					
% Initial State: 
					
% Input: 
					
% Output: 
					
% How test will be performed: 
					
% \item{test-id2\\}

% Type: Functional, Dynamic, Manual, Static etc.
					
% Initial State: 
					
% Input: 
					
% Output: 
					
% How test will be performed: 

% \end{enumerate}

% \subsection{Area of Testing2}

% ...
				
\section{Unit Testing Plan}
		
\wss{Unit testing plans for internal functions and, if appropriate, output
  files}

\bibliographystyle{plainnat}

\bibliography{SRS}

\newpage

\section{Appendix}

This is where you can place additional information.

\subsection{Symbolic Parameters}

The definition of the test cases will call for SYMBOLIC\_CONSTANTS.
Their values are defined in this section for easy maintenance.

\subsection{Usability Survey Questions?}

This is a section that would be appropriate for some teams.

\end{document}