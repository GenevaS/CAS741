\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{txfonts}
\usepackage[nocenter]{qtree}

\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=ForestGreen,
    filecolor=WildStrawberry,
    linkcolor=Purple,
    urlcolor=Cerulean
}
\usepackage[round]{natbib}

\input{../Comments}

\newcommand{\progname}{Companion Cube Calculator} % PUT YOUR PROGRAM NAME HERE
\newcommand{\prognameAbbrv}{$C^{3}$}
\newcommand{\srsVersion}{1.0.1}

\begin{document}

\title{Test Plan for the \progname{} (\prognameAbbrv{}) Tool} 
\author{Geneva Smith}
\date{\today}
	
\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
 & 1.0 & Initial draft completed\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

\renewcommand{\arraystretch}{1.2}
\begin{tabular}{l l} 
  \toprule		
  \textbf{symbol} & \textbf{description}\\
  \midrule 
  \prognameAbbrv{} & \progname{}\\
  SRS & Software Requirements Specification\\
  T & Test\\
  \bottomrule
\end{tabular}\\

\wss{symbols, abbreviations or acronyms -- you can reference the SRS tables if needed}

\newpage

\tableofcontents

\listoftables

\listoffigures

\newpage

\pagenumbering{arabic}

\section{General Information}
This document is a software test plan for the \progname{} (\prognameAbbrv{}), a 
mathematical tool which determines the range, $R(f(X))$, of a user-specified 
function, $f(X)$, given the domains of the function's variables, $D(X)$. The 
calculations are performed using interval arithmetic.

\subsection{Purpose}
This document describes the software test plan for the \prognameAbbrv{} tool 
and is informed by its SRS documentation (version \srsVersion{}), including a 
description of automated testing approach, tools, and black box test cases. The 
purpose of documenting this information is to guide the product testing for the 
initial product release and to provide a basis for regression testing as 
further developments are made to the \prognameAbbrv{} tool.

This document is intended for readers who wish to test the initial version of 
the product, as well as those who want to refine and expand the tool. As 
changes are made to the \prognameAbbrv{} tool, these test cases will form the 
foundation of regression testing and will help ensure that any changes made to 
the product do not affect its original purpose or core functionality.

This test plan is intended to be used for version 1.0 of the \prognameAbbrv{} 
tool, and will only contain test information related to the product description 
in the product's SRS documentation (version \srsVersion{}). Any functionality 
defined beyond the scope of the SRS document are not included in this version 
of the test plan.

\subsection{Scope}
The \prognameAbbrv{} tool relies on interval arithmetic in the domain of real 
numbers ($\varmathbb{R}$), which means that many of its functions can be 
empirically tested. The tool has not yet been built, so the plan will mainly 
focus on black box testing approaches. However, some white box tests might be 
specified because the models and equations that are used to calculate $R(f(X))$ 
have been explicitly defined in the SRS documentation.

The purpose of this plan is to guide the modularization of the \prognameAbbrv{} 
tool design so that it is easy to test and maintain. It also forms the 
foundation of the kinds of behaviours that the tool should exhibit when it 
encounters malformed  user inputs and unexpected values during its calculations.

\subsection{Overview of Document}
This document presents a general description of the \prognameAbbrv{} tool to 
establish the context of the test plan and a list of team members responsible 
for executing it. This background information is followed by a high-level 
description of the test plan, including the automated testing approach, 
verification tools, and non-testing based verification methods that will be 
used. The general plan outline is followed by a description of the system test 
which is designed to determine if the requirements from the associated SRS 
document are satisfied. The final section describes how unit testing will be 
implemented when the internal workings of the \prognameAbbrv{} tool are 
established.

\section{Plan}
\label{testplan_highlevel}
	
\subsection{Software Description}

\subsection{Test Team}

The test team assigned to implement this plan is Geneva Smith.

\subsection{Automated Testing Approach}

\subsection{Verification Tools}

\wss{Thoughts on what tools to use, such as the following: unit testing
  framework, valgrind, static analyzer, make, continuous integration, test
  coverage tool, etc.}

% \subsection{Testing Schedule}
		
% See Gantt Chart at the following url ...

\subsection{Non-Testing Based Verification}

\wss{List any approaches like code inspection, code walkthrough, symbolic
  execution etc.  Enter not applicable if that is the case.}

\section{System Test Description}
The system testing of the \prognameAbbrv{} tool will focus on inspecting and 
conditioning user inputs and ensuring that the \prognameAbbrv{} tool is able to 
produce descriptive outputs for both valid and invalid inputs. 

The goal of user input inspection and conditioning tests is to be sure that the 
\prognameAbbrv{} tool is able to identify and reject values that violate the 
assumptions. If the tool determines that the values do not violate the 
assumptions, it should be able to convert those values into the internal 
representations identified in the SRS document. For the purposes of this test 
plan, it is assumed that the user function $f(X)$ is represented internally as 
a parse tree.

Even if the user inputs are validated and conditioned correctly, it is still 
possible for the \prognameAbbrv{} tool to encounter invalid operations in an 
intermediary step while calculating a result. This makes it necessary to create 
a series of tests to determine how the tool will react to both supported and 
unsupported operations.
	
\subsection{Tests for Functional Requirements}

\subsubsection{Getting User Inputs}
This test suite is designed to determine if the \ref{R_Inputs} functional 
requirement is satisfied.

\paragraph{User Inputs (As Expected)}

\begin{enumerate}
	
	\item{test-directinput}
	
	Type: Functional
	
	Initial State: New Session
	
	Input: $f(X) = x + y, x = [2,4], y = [2,4]$
	
	Output: Input received from direct input
	
	How test will be performed: Unit Test\\
	
	\item{test-fileinput}

	Type: Functional
	
	Initial State: New Session
	
	Input: File containing: $f(X) = x + y, x = [2,4], y = [2,4]$
	
	Output: Input received from file
	
	How test will be performed: Unit Test\\
	
	\item{test-badFileInput}
	
	Type: Functional
	
	Initial State: New Session
	
	Input: File that cannot be read
	
	Output: Error -- File cannot be read
	
	How test will be performed: Unit Test\\
\end{enumerate}
	
\paragraph{User Inputs (Function is a Constant Value)}

\begin{enumerate}	
	\item{test-input\_functionAsConstant}
	
	Type: Functional
	
	Initial State: New Session
	
	Input: $f(X) = 34$
	
	Output: N/A
	
	How test will be performed: Unit Test\\
\end{enumerate}
	
\paragraph{User Inputs (Extraneous Information)}
	
\begin{enumerate}
	\item{test-input\_variableNotInFunction}
	
	Type: Functional
	
	Initial State: New Session
	
	Input: $f(X) = 34$, $x = [2,4]$
	
	Output: Warning -- Function $f(X)$ does not contain name $x$ found in 
	variable list
	
	How test will be performed: Unit Test\\
	
\end{enumerate}
		
\paragraph{User Inputs (Missing Values)}

\begin{enumerate}

\item{test-input\_noFunction}

Type: Functional

Initial State: New Session

Input: $x = [2,4], y = [2,4]$

Output: Error -- Could not find function $f(X)$ with variables $x, y$

How test will be performed: Unit Test\\

\item{test-input\_noDomain}

Type: Functional
					
Initial State: New Session
					
Input: $f(X) = x + y$, $x = [2,4]$
					
Output: Error -- No domain for variable $y$
					
How test will be performed: Unit Test\\

\end{enumerate}

\paragraph{User Inputs (Incomplete Values)}

\begin{enumerate}
	
	\item{test-input\_missingFunctionValue}
	
	Type: Functional
	
	Initial State: New Session
	
	Input: $f(X) = x +$, $x = [2,4], y = [3,5]$
	
	Output: Error -- Function $f(X)$ is missing an operand for $+$
	
	How test will be performed: Unit Test\\
	
	\item{test-input\_missingMinDomainValue}
	
	Type: Functional
	
	Initial State: New Session
	
	Input: $f(X) = x + y$, $x = [,4], y = [3,5]$
	
	Output: Error -- Missing min domain value for $x$
	
	How test will be performed: Unit Test\\
	
	\item{test-input\_missingMaxDomainValue}
	
	Type: Functional
	
	Initial State: New Session
	
	Input: $\{f(X) = x + y, x = [2,4], y = [3,]\}$, $\{f(X) = x + y, x = 
	[2,4], y = [3]\}$
	
	Output: Error -- Missing max domain value for $y$
	
	How test will be performed: Unit Test
	
\end{enumerate}

\subsubsection{Conditioning User Inputs}
This test suite is designed to determine if the \ref{R_conditionX} and 
\ref{R_conditionfx} functional requirements are satisfied.

\paragraph{Parsing User Inputs (Single Operators)}

\begin{enumerate}
	
	\item{test-parse\_addition\\}
	
	Type: Functional
	
	Initial State: New Session
	
	Input: $f(X) = x + y$, $x = [2,4], y = [3,5]$
	
	Output: \Tree[.$+$ [.$x$ $[2,4]$ ] [.$y$ $[3,5]$ ] ]
	
	How test will be performed: Unit Testing
	
	\item{test-parse\_subtraction\\}
	
	Type: Functional
	
	Initial State: New Session
	
	Input: $f(X) = x - y$, $x = [2,4], y = [3,5]$
	
	Output: \Tree[.$-$ [.$x$ $[2,4]$ ] [.$y$ $[3,5]$ ] ]
	
	How test will be performed: Unit Testing
	
	\item{test-parse\_multiplication\\}
	
	Type: Functional
	
	Initial State: New Session
	
	Input: $f(X) = x \times y$, $x = [2,4], y = [3,5]$
	
	Output: \Tree[.$\times$ [.$x$ $[2,4]$ ] [.$y$ $[3,5]$ ] ]
	
	How test will be performed: Unit Testing
	
	\item{test-parse\_division\\}
	
	Type: Functional
	
	Initial State: New Session
	
	Input: $f(X) = x \div y$, $x = [2,4], y = [3,5]$
	
	Output: \Tree[.$\div$ [.$x$ $[2,4]$ ] [.$y$ $[3,5]$ ] ]
	
	How test will be performed: Unit Testing
	
	\item{test-parse\_divisionMixedInterval\\}
	
	Type: Functional
	
	Initial State: New Session
	
	Input: $f(X) = x + y$, $x = [2,4], y = [-3,5]$
	
	Output: Error -- Cannot perform division with a mixed interval divisor
	
	How test will be performed: Unit Testing
	
	\item{test-parse\_intervalAsExponents\\}
	
	Type: Functional
	
	Initial State: New Session
	
	Input: $f(X) = 2^x$, $x = [2,4]$
	
	Output: %\Tree[.$\^$ [.$2$ ] [.$x$ $[2,4]$ ] ]
	
	How test will be performed: Unit Testing
	
\end{enumerate}

\subsection{Tests for Non-Functional Requirements}

\subsubsection{Area of Testing1}
		
\paragraph{Title for Test}

\begin{enumerate}

\item{test-id1\\}

Type: 
					
Initial State: 
					
Input/Condition: 
					
Output/Result: 
					
How test will be performed: 
					
\item{test-id2\\}

Type: Functional, Dynamic, Manual, Static etc.
					
Initial State: 
					
Input: 
					
Output: 
					
How test will be performed: 

\end{enumerate}

\subsubsection{Area of Testing2}

...

\subsection{Traceability Between Test Cases and Requirements}

% \section{Tests for Proof of Concept}

% \subsection{Area of Testing1}
		
% \paragraph{Title for Test}

% \begin{enumerate}

% \item{test-id1\\}

% Type: Functional, Dynamic, Manual, Static etc.
					
% Initial State: 
					
% Input: 
					
% Output: 
					
% How test will be performed: 
					
% \item{test-id2\\}

% Type: Functional, Dynamic, Manual, Static etc.
					
% Initial State: 
					
% Input: 
					
% Output: 
					
% How test will be performed: 

% \end{enumerate}

% \subsection{Area of Testing2}

% ...
				
\section{Unit Testing Plan}
		
\wss{Unit testing plans for internal functions and, if appropriate, output
  files}

\bibliographystyle{plainnat}

\bibliography{SRS}

\newpage

\section{Appendix}

This is where you can place additional information.

\subsection{Symbolic Parameters}

The definition of the test cases will call for SYMBOLIC\_CONSTANTS.
Their values are defined in this section for easy maintenance.

\subsection{Usability Survey Questions?}

This is a section that would be appropriate for some teams.

\end{document}